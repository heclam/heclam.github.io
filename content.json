{"posts":[{"title":"Ajax","text":"当我们使用AJAX之后，浏览器是先把请求发送到XMLHttpRequest异步对象之中，异步对象对请求进行封装，然后再与发送给服务器。服务器并不是以转发的方式响应，而是以流的方式把数据返回给浏览器 XMLHttpRequest异步对象会不停监听服务器状态的变化，得到服务器返回的数据，就写到浏览器上【因为不是转发的方式，所以是无刷新就能够获取服务器端的数据】 XMLHttpRequest对象1234567891011function getXHR() { //根据对象判断浏览器 if(window.XMLHttpRequest) { //不是IE return new XMLHttpRequest(); }else{ //IE return new ActiveXObject(&quot;Microsoft.XMLHttp&quot;); }}var xhr = getXHR(); get方式请求12345//参数解析： 第一个参数：表示请求的方式 第二个参数：表示请求的地址 第三个参数：表示是否为异步请求（true表示发送异步请求）xhr.open(&quot;get&quot;, url, true); 发送请求1xhr.send(null); 回调函数XHR 对象的readyState 属性可取的值： 0：未初始化。尚未调用open()方法。 1：启动。已经调用open()方法，但尚未调用send()方法。 2：发送。已经调用send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 只要readyState 属性的值由一个值变成另一个值，都会触发一次readystatechange 事件。可以利用这个事件来检测每次状态变化后readyState 的值。 12345678xhr.onreadystatechange = function(){ //当请求结束且没报错时 if(xhr.readyState==4 &amp;&amp; xhr.status==200) { var txt = xhr.responseText; console.log(txt); }}; responseText:作为响应主体被返回的文本 responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM 文档。 post请求123456789101112xhr.open(&quot;post&quot;,url, true);//设置请求头xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//发送form表单数据var form = document.getElementById(&quot;form&quot;);//发送序列化的表单xhr.send(serialize(form));//发送普通数据xhr.send(&quot;name = abc&quot;);xhr.send(&quot;book = JavaScript&quot;); $.ajax()语法： $.ajax({key:value,key:value}) 例如： 1234567891011121314151617181920$.ajax({ type: &quot;GET&quot;, //String类型参数，请求方式POST或GET,默认为GET,请求方式 url: &quot;xxx&quot;, //String类型参数，发送请求的地址 async: true, //Boolean类型参数，表示为异步请求，默认为true cache: false, //Boolean类型参数，是否设置缓存,默认为false contentType: xxx, //发送信息至服务器时内容编码类型 data: String , //Object或String类型参数，发送到服务器的数据，比如为&quot;json&quot; dataType: String, //String类型参数，服务器返回的数据类型 success: function(data){}//成功回调的函数 error:function(data){} //失败回调函数});","link":"/2019/06/26/Ajax/"},{"title":"Cookie笔记","text":"何为会话用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 Cookie的流程：浏览器访问服务器，如果服务器需要记录该用户的状态，就使用response向浏览器发送一个Cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同Cookie一同交给服务器。 ​ 创建一个Cookie对象，发送给浏览器 ​ Cookie cookie = new Cookie(key,valus); //创建Cookie对象，指定名称和值 ​ Cookie.setAge(秒); //设置时间 ​ response.addCookie(cookie);//向浏览器发送一个cookie 保存会话数据的两种技术Cookie和Session Cookie API 方法 类型 描述 Cookie(String name ,String value) 构造方法 实例化Cookie对象，传入Cookie名称和Cookie值 public String getName() 普通方法 获取Cookie的名称 public String getValue() 普通方法 获取Cookie的值 public String setValue() 普通方法 设置Cookie的值 public void setMaxAge(int expiry) 普通方法 设置Cookie的有效期，如果expiry为正数，浏览器会把Cookie写入到硬盘中，如果为负数，Cookie是临时的 public int getMaxAge() 普通方法 获取Cookie的有效期 setPaht(String uri) 与getPath() 普通方法 有效路径 setDomain(String pattern)与getDomain() 普通方法 有效域 一个Cookie例子1234567891011121314151617181920212223public class ServletDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置服务器端以UTF-8编码进行输出 response.setCharacterEncoding(&quot;UTF-8&quot;); //设置浏览器以UTF-8编码进行接收,解决中文乱码问题 response.setContentType(&quot;text/html;charset=UTF-8&quot;); //创建一个Cookie对象,并指定名称和值 Cookie cookie = new Cookie(&quot;username&quot;,&quot;abc&quot;); //设置cookie有效期 cookie.setMaxAge(1000); //向浏览器添加一个Cookie response.addCookie(cookie); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 获取Cookie 12345Cookie[] cookies = request.getCookies(); for (int i = 0;cookies! = null &amp;&amp; i &lt; cookies.length; i++) { String name = cookies[i].getName(); String Value = cookies[i].getValue(); } 一些Cookie方法的解析Cookie有效期： 如果MaxAge为正数，浏览器会把Cookie写到硬盘中，只要还在MaxAge秒之前，登陆网站时该Cookie就有效【不论关闭了浏览器还是电脑】 如果MaxAge为负数，Cookie是临时性的，仅在本浏览器内有效，关闭浏览器Cookie就失效了，Cookie不会写到硬盘中。Cookie默认值就是-1。 如果MaxAge为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie对应的方法，把MaxAge设置为0等同于删除Cookie Cookie中存取中文123456//Cookie存储中文的时候需要使用URLEncoder类里面的encode(String s,String enc)方法进行中文转码Cookie cookie = new Cookie(&quot;userName&quot;, URLEncoder.encode(&quot;孤傲苍狼&quot;, &quot;UTF-8&quot;));response.addCookie(cookie);//获取Cookie中的中文，需要使用URLEncoder类里面的decode(String s,String enc)进行解码URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;)","link":"/2019/07/08/Cookie%E7%AC%94%E8%AE%B0/"},{"title":"erlang节点","text":"两个重要的概念： 1. 复制式进程间通信 2. 位置透明性 1、节点与集群：Erlang VM 实例称为节点 两个或两个以上的Erlang节点能够相互感知，它们就形成了一个集群 2、节点的启动只要给erl（或werl）加上命令行参数-name或-sname,就可以以分布式模式启动Erlang节点 第一种形式适用于配有DNS的普通环境，需要给出节点的完全限定域名 erl -name simple_cache 第二种形式适用于完全限定域名不可用的情况,可以使用短节点名 erl -sname simple_cache 只有采用相同模式的节点才能互联 windows下启动节点，可以直接找到Erlang图标，可以复制多个快捷方式，然后右击属性，在目标地址栏添加参数如 'url' -sname a, 随后直接点击图标就可以启动a节点了 3、节点互联​ 在节点内可以通过nodes()，检查节点间的互联情况 12345678% 对一个节点建立连接% 成功返回pong,失败返回pang% net_adm:ping('节点名称') net_adm:ping('B@xxxx'). % 默认情况下，每个节点都会假定所有与自己打交道的节点都拥有和自己一样的cookieauth:get_cookie() % 获取cookieset_cookie(Node,Cookie) % 设置cookie epmd(Erlang Port Mapper Daemon) 是Erlang的端口映射守护进程，这是一个操作系统级的守护进程，当erlang的节点启动时，会将节点名称和地址发送给epmd, epmd会记录当前机器下节点的信息，主机间可以通过epmd交换双方机器下的节点信息并进行连接。 不管运行了多少个Erlang节点，每个计算机只运行一个epmd，它随Erlang节点的第一次启动而启动，不随Erlang节点的结束而结束。 epmd负责监听4369端口上的连接请求,然后将其映射给相应节点的监听端口 123456789% 使用 erl_epmd:names() 查看epmd注册的节点% 查看本机的epmd下注册的节点erl_epmd:names()% 查看其他机器下的epmd注册的节点erl_epmd:names('ip地址')% 若双方能通过erl_epmd:name('对方的ip') 看到对方epmd下注册的节点，说明双方的epmd端口至少是互通的 节点互联要素 1、要有相同的cookie 2、命名（节点可以使用短命名(-sname) 或长命名(-name)启动，短命名和长命名的节点不能进行通信 3、开放端口 (在不同主机进行通信时，需要开放节点通信所需要的端口, 开放epmd端口4369)，其次节点的动态端口是可以访问的 版本： erlang允许不同操作系统的erlang节点进行互联，但是不允许主版本不同的erlang节点进行连接。例如erlang R16 不能与erlang R17互联(查看主版本指令 erlang:system_info(otp_release)) 通过nodes(hidden) 或 nodes(connected) 查看hidden nodes hidden node 的一个用法是作为“网关”将许多小的分布式集群连接起来。另外一个用法是用来做维护，它不会影响流量 123456%% 查看允许被访问的节点net_kernel:allowed()%% 如果为空则允许所有节点访问，不为空则只允许列表中的节点访问%% 添加允许被访问的节点net_kernel:allow(节点名称列表) 4、远程Shell123456789101112131、在节点终端ctrl+G % 打开任务控制接口2、开始远程shellr ‘b@xxx’3、j查看任务4、c 执行相应的任务5、退出远程shell第一步通过c 直接切换任务第二部 k 任务编号 另外一种接入控制台的方法 12%% 这样直接进入了node_1节点werl -setcookie abc -name node_2@127.0.0.1 -remsh node_1@127.0.0.1","link":"/2024/03/13/Erlang%E8%8A%82%E7%82%B9/"},{"title":"JSP笔记","text":"何为JSP ？ JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP这门技术的最大的特点在于，写jsp就像在写html，但它相比html而言，html只能为用户提供静态数据，而Jsp技术允许在页面中嵌套java代码，为用户提供动态数据。 JSP原理浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet，服务器在执行jsp的时候，首先把jsp翻译成一个Servlet，所以我们访问jsp时，其实不是在访问jsp，而是在访问jsp翻译过后的那个Servlet 为什么有了Servlet了还需要JSP呢？其实JSP的出现是简化了Servlet，之前我们要展示一个页面要在Servlet中写 1234out.write(&quot;&lt;html&gt;&quot;);out.write(&quot;&lt;body&gt;&quot;);out.write(&quot;&lt;/body&gt;&quot;);out.write(&quot;&lt;/html&gt;&quot;); 之类的代码，显得太过麻烦了，所以就出现了JSP。 JSP的生命周期jsp的生命周期类似于servlet的生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。 JSP生命周期的阶段： 编译阶段(解析JSP文件，将JSP文件转换为servlet，然后编译servlet)* servlet容器编译servlet源文件，生成servlet类 初始化(执行 jspInit()方法) 加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法 执行阶段（执行 _jspService(HttpServletRequest request,HttpServletResponse response) 方法） 调用与JSP对应的servlet实例的服务方法 销毁阶段（执行jspDestroy()方法 ） 调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例 1编译阶段 --&gt; jspInit() --&gt; _jspServcie() --&gt; jspDestroy() jsp获取绝对路径​ 代码” ${pageContext.request.contextPath}”的作用是取出部署的应用程序名，这样不管如何部署，所用路径都是正确的 1234&lt;!--使用绝对路径的方式引入CSS文件--&gt;2 &lt;link rel=&quot;stylesheet&quot; href=&quot;${pageContext.request.contextPath}/css/xxx.css&quot; type=&quot;text/css&quot;/&gt;3 &lt;!--使用绝对路径的方式引入JavaScript脚本--&gt;4 &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath}/js/xxx.js&quot;&gt;&lt;/script&gt; 使用&lt;%=request.getContextPath()%&gt;和使用${pageContext.request.contextPath}达到同样的效果 静态包含与动态包含&lt;%@include file=”name.jsp”%&gt; include指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！ &lt;%jsp:include page=”name.jsp”%&gt; jsp行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中 动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！ 防止表单重复提交 利用javascript防止表单重复提交 123456789101112131415&lt;form onsubmit=&quot;return dosubmit()&quot;&gt; 这是表单内容&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var isCommitted = false;//表单是否已经提交标识，默认为false 8 function dosubmit(){ 9 if(isCommitted==false){10 isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true11 return true;//返回true让表单正常提交12 }else{13 return false;//返回false那么表单将不提交14 }15 }&lt;/script&gt; 还有一种方法是，当表单提交之后，设置提交按钮不可用 12345678function dosubmit(){2 //获取表单提交按钮3 var btnSubmit = document.getElementById(&quot;submit&quot;);4 //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮5 btnSubmit.disabled= &quot;disabled&quot;;6 //返回true让表单可以正常提交7 return true;8 }","link":"/2019/07/08/JSP%E7%AC%94%E8%AE%B0/"},{"title":"linux基础服务搭建","text":"1234567891011121314151617# 基础环境CentOS7# 网络工具 （虚拟机初始安装的时候没有这个，需要安装）yum search ifconfigyum install net-tools.x86_64# 然后才可以使用 ifconfig （网卡）# 安装远程同步工具yum install -y rsyncyum install -y libnuma.so.1 numactl # 创建用户 groupadd wwwuseradd www -s /sbin/nologin -M -g www 多实例MySql(5.6.13 linux-Generic)123456789101112131415161718192021222324# 安装依赖yum install libaio# mysql下载地址https://downloads.mysql.com/archives/community/# 将下载的文件上传到 /usr/local/src/ 目录下mysql-5.6.13-linux-glibc2.5-x86_64.tar.gz# 不需要卸载自带的mariadb#创建用户和用户组groupadd mysqluseradd mysql -s /sbin/nologin -M -g mysql# 解压安装包（将安装包解压到/usr/local/mysql56/ 目录下）tar -zxvf mysql-5.6.13-linux-glibc2.5-x86_64.tar.gz -C /usr/local# 重新命名cd /usr/local/mv mysql-5.6.13-linux-glibc2.5-x86_64/ mysql56# 建立一个软连接ln -s /usr/local/mysql56 /usr/local/mysql 安装 Mongodb（3.6.12） (使用tar包方式)12345678910111213# 去官网地址https://www.mongodb.com/download-center/community/releases/archive# 选择3.6.12版本下载https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.12.tgz# 上传到/usr/local/src/ 目录# 执行解压命令 (一下合成一步)tar -xvzf mongodb-linux-x86_64-rhel70-3.6.12.tgz -C /usr/local/# 重新命名cd /usr/local/mv mongodb-linux-x86_64-rhel70-3.6.12 mongodb-3.6.12 安装Nginx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 查看nginx的configure/usr/local/nginx/sbin/nginx -V# 输出的内容为nginx version: nginx/1.17.9built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabled # 支持一个服务器使用多个域名证书的TLS扩展，支持用户配置多个域名证书# 支持单IP多域名SSL证书需要OpenSSL支持configure arguments: --user=www # 指定Nginx woker进程运行时所属的用户 --group=www # 指定Nginx woker进程运行时所属的组 --prefix=/usr/local/nginx # Nginx安装部署后的根目录，默认为/usr/local/nginx # 安装http stub_status模块。该模块可以让运行中的Nginx提供性能统计页面，获取相关的并发链接 --with-http_stub_status_module # 安装http ssl 模块。该模块使Nginx支持SSL协议，提供HTTPS服务。注意：该模块依赖openssl --with-http_ssl_module # 安装http realip模块。该模块可以从客户端请求的header信息（如X-Real-IP或者X-Forwarder-For)获取真正客户端的IP地址 --with-http_realip_module # 安装http image_filter模块。这个模块将符合配置的图片实时压缩为指定大小的缩略图再发送给用户，目前支持JPEG、PNG、GIF格式。注意：该模块依赖libgb库 --with-http_image_filter_module # 用来集成Google的高性能工具集(Google Performance tools 简称gperftools),这个工具集可以提供更好的内存和CPU性能分析。需要安装依赖 gperftools-libs gperftools-devel --with-google_perftools_module --with-stream # 开启TCP/IP代理模块 --with-stream_ssl_module# 安装前的准备# 如果指定用户和用户组需要提前创建，如WWW用户# 依赖包的安装yum -y install gcc gcc-c++ autoconf automake libtool make cmakeyum -y install zlib zlib-devel openssl openssl-devel pcre-devel gd-devel google-perftools google-perftools-devel# 有些参数设置需要的依赖包 (需要安装依赖才能configure成功)# gd-devel (--with-http_image_filter_module 需要的依赖)# google-perftools google-perftools-devel (--with-google_perftools_module 需要的依赖)# 从官网下载nginx 稳定版本 并上传到服务器 /usr/local/srchttps://nginx.org/en/download.html# 解压tar -zxvf nginx-1.26.0.tar.gz# 进入nginx-1.26.0目录并执行 (编译配置、编译、安装)./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module --with-http_image_filter_module --with-google_perftools_module --with-stream --with-stream_ssl_module# 编译make# 安装make install# 查看安装后的程序版本/usr/local/nginx/sbin/nginx -v# 如果修改nginx配置,验证配置是否合法/usr/local/nginx/sbin/nginx -t# 启动nginx/usr/local/nginx/sbin/nginx# 重启nginx/usr/local/nginx/sbin/nginx -s reload# 停止nginx/usr/local/nginx/sbin/nginx -s quit/usr/local/nginx/sbin/nginx -s stop# curl 访问localhost测试curl localhost# 对外访问需要开放端口（按需开放）firewall-cmd --add-port=80/tcp --permanent firewall-cmd --add-port=443/tcp --permanent firewall-cmd --reload #重载防火墙配置 安装php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 查看php的configure (以下为配置路径文件)/usr/local/php7.3.10/bin/php-config# 安装前的准备# 如果指定用户和用户组需要提前创建，如WWW用户 (configure会用到)# 从官网上下载https://www.php.net/releases/ # 选择7.3.10版本# 下载链接https://www.php.net/distributions/php-7.3.10.tar.gz# 安装依赖库yum -y install libxml2 libxml2-devel openssl openssl-devel curl-devel libjpeg-devel libpng-devel freetype-devel libmcrypt-devel bzip2-devel readline-devel # 大部分依赖包(此项不执行) yum install -y wget gcc gcc-c++ autoconf libjpeg libjpeg-devel perl perl* perl-CPAN libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers png jpeg autoconf gcc cmake make gcc-c++ gcc ladp ldap* ncurses ncurses-devel zlib zlib-devel zlib-static pcre pcre-devel pcre-static openssl openssl-devel perl libtoolt openldap-devel libxml2-devel ntpdate cmake gd* gd2 ImageMagick-devel jpeg jpeg* pcre-dev* fontconfig libpng libxml2 zip unzip gzip # 上传源码安装包到/usr/local/src/目录,并解压tar -zxvf php-7.3.10.tar.gz cd php-7.3.10# 源码编译、安装./configure --prefix=/usr/local/php7.3.10 --with-config-file-path=/usr/local/php7.3.10/etc/ --enable-fpm --enable-cli --enable-mbstring --enable-soap --enable-opcache --enable-pcntl --enable-shmop --enable-sysvmsg --enable-sysvsem --enable-sysvshm --enable-sockets --enable-zip --with-bz2 --with-readline --disable-fileinfo --disable-rpath --with-mysqli --with-pdo-mysql --with-iconv-dir --with-fpm-user=www --with-fpm-group=www --with-mhash --with-gd --with-jpeg-dir --with-png-dir --with-freetype-dir --with-zlib --enable-simplexml --with-libxml-dir --with-openssl --with-curl --enable-maintainer-zts# 这里configure报错，看下面 configure报错解决# 编译make# 对编译结果测试make test# 安装make install# 查看安装成功后的版本信息/usr/local/php7.3.10/bin/php -v# 修改配置cp /usr/local/src/php-7.3.10/php.ini-production /usr/local/php7.3.10/etc/php.ini修改php.ini文件display_errors = Off 修改为 display_errors = on# 因为后续中央服需要mongodb的支持，所以这里需要添加响应的扩展# 具体操作看以下php扩展文件的最后面加上以下代码：extension=redis.soextension=fileinfo.soextension=mongodb.so;extension=sockets.so;extension=openssl.so# 启用php-fpm服务cd /usr/local/php7.3.10/etccp php-fpm.conf.default php-fpm.confcp php-fpm.d/www.conf.default php-fpm.d/www.conf # 基本这个配置不用改 注意user与group为www 安装php的时候就已指定#启动php-fpm/usr/local/php7.3.10/sbin/php-fpmhttps://blog.csdn.net/ziqibit/article/details/129562734 configure报错解决123456789101112131415161718192021222324252627282930313233# ./configure会报错 (如果安装yum install libzip-devel -y)# configure: error: Please reinstall the libzip distribution# checking for libzip... configure: error: system libzip must be upgraded to version &gt;= 0.11# 如果用yum安装libzip-devel的话，安装的版本时0.10，版本达不到要求，所以需要卸载libzip后手动安装新版本# 1、移除旧版本yum remove libzip libzip-devel# 2、到https://libzip.org/news/ 下载1.5.2版本https://libzip.org/download/libzip-1.5.2.tar.gz# 3、解压tar -zxvf libzip-1.5.2.tar.gz# cd libzip-1.5.2# mkdir build# cd build# cmake .. (#注意：cmake后面有两个小数点, 有可能这一步会报cmake版本过低，以下有升级的方法)]# make -j4# make test# make install# 4、执行完上面后，configure还是会报错# configure: error: off_t undefined; check your library configuration#在/etc/ld.so.conf.d/路劲下创建usr_local_lib.conf 文件，并添加以下内容/usr/local/lib/usr/local/lib64/usr/lib/usr/lib64# 5、保存,让修改的文件生效ldconfig -v# 改完后configure还是报错，参考https://blog.csdn.net/weixin_43493122/article/details/96647432 Cmake版本太低了（升级Cmake）1234567891011121314151617181920212223# 报错 CMake 3.0.2 or higher is required. You are running version 2.8.12.2#升级Cmake#1、移除旧版本yum remove cmake -y#2、从官网上下载https://cmake.org/files/v3.17/ (选择3.17.5版本)https://cmake.org/files/v3.17/cmake-3.17.5-Linux-x86_64.tar.gz#上传到/usr/local/src目录中#3、进行一个解压：tar -zxvf cmake-3.17.5-Linux-x86_64.tar.gz#4、增加环境变量vim /etc/profile#在文件末尾添加以下代码 并保存：export PATH=$PATH:/usr/local/src/cmake-3.17.5-Linux-x86_64/bin#使修改的文件生效：source /etc/profile#5、验证echo $PATHcmake --version php安装扩展1234567891011121314151617181920212223242526# cd /usr/local/src/wget http://pecl.php.net/get/mongodb-1.5.2.tgz# 解压tar -zxvf mongodb-1.5.2.tgz# 切换目录 cd mongodb-1.5.2# 执行 （以下就是php的安装目录)/usr/local/php7.3.10/bin/phpize./configure --with-php-config=/usr/local/php7.3.10/bin/php-configmake &amp;&amp; make install# 安装成功后，会有类似以下安装目录信息输出：#Installing shared extensions: /usr/local/php7.3.10/lib/php/extensions/no-debug-zts-20180731# 修改配置vim /usr/local/php7.3.10/etc/php.ini# 在文档末尾加入extension-mongodb.so#然后重启php-fpm 安装Redis123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 下载安装包：(下载至/usr/local/src/ 目录下)wget http://download.redis.io/releases/redis-7.0.11.tar.gztar xzf redis-7.0.11.tar.gz -C /usr/local/#mv redis-7.0.11 ../ # 移动解压文件到上一层，也就是/usr/local/目录下cd redis-7.0.11make PREFIX=/usr/local/redis-7.0.11/ -j4 install# 创建目录 (中央服依赖这个)mkdir /data/redis/33379/{conf,data,logs} -p# 配置cp -a /usr/local/redis-7.0.11/redis.conf /data/redis/33379/conf/# 修改/data/redis/33379/conf/redis.conf配置---- 33379 ----bind 127.0.0.1protected-mode yes #开启保护模式port 33379 #端口pidfile /var/run/redis_33379.pid #进程idlogfile /data/redis/33379/logs/redis-server.log #日志dir /data/redis/33379/data/ #数据目录repl-diskless-sync noappendonly yes #开启持久化requirepass zusI9fuCMI5eHP2X #设置密码 rename-command FLUSHALL &quot;&quot;rename-command CONFIG &quot;&quot;rename-command EVAL &quot;&quot;# 修改/usr/local/redis-7.0.11/redis.conf配置 (应该用不到这个配置启动redis的,先不做处理)-------/usr/local/redis-7.0.11/redis.confbind 0.0.0.0dir /data/redis/ #数据目录appendonly yes# 测试（在/root/目录下创建脚本start-redis.sh)#!/bin/bash/usr/local/redis-7.0.11/bin/redis-server /data/redis/33379/conf/redis.conf#启动redissh /root/start-redis.sh#连接（因为上面设置了密码、所以也需要密码连接）/usr/local/redis-7.0.11/bin/redis-cli -h 127.0.0.1 -p 33379 -a zusI9fuCMI5eHP2X ping# 返回pong则为成功 安装Erlang12345678910111213# 从官网上下载erlnag25https://github.com/erlang/otp/releases/download/OTP-25.2.1/otp_src_25.2.1.tar.gz# 安装依赖yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel# 上传文件到/usr/local/src/目录下 并解压tar -zxvf otp_src_25.1.2.tar.gz# 编译cd otp_str_25.1.2./configure --prefix=/usr/local/erlang25make -j2 &amp;&amp; make install 12345678# centos7 安装使用rz/sz命令yum install -y lrzsz# 创建软链接ln -s [源文件] [软链接文件]ln -s /usr/lib64/libtcmalloc.so /usr/local/lib/libtcmalloc.so# 创建的软链接文件为/usr/local/lib/libtcmalloc.so 12需要开放的端口：80 // nginx","link":"/2024/05/11/Linux%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"},{"title":"Linux服务器运行环境配置","text":"一台云服务器需要搭建的运行环境，包括JDK、MySQL、Tomcat、Nginx等，该服务器（CentOS7）用于部署JavaEE项目 一、JDK安装卸载自带的openJDK​ 因为centos有自带的jdk，所以在安装自己的JDK时需要卸载自带的openJDK 使用rpm -qa | grep java命令查看系统中是存在有java 使用rpm -e –nodeps 相关应用名称来进行卸载 12345678[root@localhost ~]# rpm -qa | grep javajava-1.8.0-openjdk-headless-1.8.0.161-2.b14.el7.x86_64tzdata-java-2018c-1.el7.noarchpython-javapackages-3.4.1-11.el7.noarchjavapackages-tools-3.4.1-11.el7.noarchjava-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64[root@localhost ~]# rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.161-2.b14.el7.x86_64[root@localhost ~]# rpm -e --nodeps java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64 下载并安装JDK 下载ORAClE所提供的JDK,传送门可根据自己的系统来进行选择相应的版本，我这选择的是jdk-8u221-linux-x64.tar.gz 从本地上传文件到服务器，需要安装Irzsz: yum -y install lrzsz (注：参数-y中”y”的意思是：当安装过程提示选择全部为”yes”) rz中的r意为received（接收），输入rz时、意为服务器接收文件，既将文件从本地上传到服务器。sz中的s意为send（发送），输入sz时、意为服务器要发送文件，既从服务器发送文件到本地，或是说本地从服务器上下载文件。注：不论是send还是received，动作都是在服务器上发起的。 将文件上传到***/usr/java目录下，然后使用tar -zxvf jdk-8u221-linux-x64.tar.gz***进行解压 修改profile配置文件使用vi /etc/profile打开，并加入以下内容（注：传送门不熟悉vi可以先去学习以下基本操作） 123export JAVA_HOME=/usr/java/jdk1.8.0_221(这个根据你解压之后的名称来定)export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 保存退出之后需要运行source /etc/profile使配置生效 最后执行java -version验证是否安装成功 123java version &quot;1.8.0_221&quot;Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 二、MySQL安装卸载之前安装的mysql 使用以下命令查看当前安装mysql的情况，看是否有安装mysql 1rpm -qa | grep -i mysql 停止mysql服务，删除之前安装的mysql 1rpm -e --nodeps mysql(mysql表示为相关的应用名称) 查找之前老版本mysql的目录、并且删除老版本的文件和库 12345678find / -name mysql删除对应的mysql目录rm -rf /var/lib/mysql(这个是由上述命令查询出来的)...还要手动删除/etc/my.cnf文件rm -rf /etc/my.cnf 再次验证机器是否由安装mysql 1rpm -qa | grep -i mysql 安装mysql123wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-server 权限设置： 1chown mysql:mysql -R /var/lib/mysql 初始化MySQL: 1234mysqld --initialize如果报 Fatal error: Please read &quot;Security&quot; section of the manual to find out how to run mysqld as root!错误信息则在/etc/my.cnf中添加一个用户，比如user=mysql那么在启动的时候就需要：mysqld --initialize --user=mysql来初始化 启动MySQL: 1systemctl start mysqld 查看MySQL运行状态： 1systemctl status mysqld 验证MySQL是否安装123[root@localhost ~]# mysqladmin --version如果出现以下内容则证明安装成功，否则则为失败mysqladmin Ver 8.42 Distrib 5.6.45, for Linux on x86_64 使用MySQL Client(Mysql客户端)执行简单的SQL命令123[root@localhost ~]# mysql就会出现mysql&gt; 这里输入平常的sql命令即可 为root用户添加密码123[root@localhost ~]# mysqladmin -u root password &quot;新密码&quot;;那么就可以通过以下命令来连接Mysql服务器[root@localhost ~]# mysql -u root -p 三、Tomcat安装 需要先下载tomcat,传送门，我下载的是apache-tomcat-9.0.24.tar.gz 将这个文件上传到/usr/local/tomcat里面进行解压 启动tomcat 1234切换到以下目录cd /usr/local/tomcat/apache-tomcat-9.0.24/bin执行 ./startup.sh 可以通过ip addr查看linux的ip地址，然后在本机上输入*** ip地址：8080 *** 四、nginx安装需要安装几个必备的库 123yum install gcc-c++ //安装gcc环境yum install -y pcre pcre-develyum install -y openssl openssl-devel 安装上传本地的压缩包到/usr/local目录进行解压，我使用的是nginx-1.12.2.tar.gz,可以到传送门下载 123456789解压：tar -zxvf nginx-1.12.2.tar.gz创建Makefile文件：[root@localhost ~]# cd nginx-1.12.2[root@localhost nginx-1.12.2]# ./configure编译：[root@localhost nginx-1.12.2]# make安装：[root@localhost nginx-1.12.2]# make install Nginx启动与访问编译安装的Nginx其实默认被安装在CentOS7系统的***/usr/local/nginx***目录 123启动Nginx(到/usr/local/nginx目录下)[root@localhost nginx]# cd sbin[root@localhost sbin]# ./nginx 在本地输入服务器的地址 即可访问到Nginx欢迎界面，可以通过 ip addr获取到地址 如果访问不到则关闭CentOS7的防火墙，开放80端口 123[root@localhost sbin]# systemctl stop firewalld.service #停止firewall[root@localhost sbin]# systemctl disable firewalld.service #禁止firewall开机启动[root@localhost sbin]# firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） Nginx的基本操作123456789101112查看Nginx进程：[root@localhost sbin]# ps aux|grep nginx关闭Nginx:[root@localhost sbin]# ./nginx -s stop或：[root@localhost sbin]# ./nginx -s quit重启Nginx:[root@localhost sbin]# ./nginx -s reload检查Nginx配置文件是否正确：[root@localhost sbin]# ./nginx -t","link":"/2019/09/07/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"mnesia","text":"MnesiaMnesia是一套轻量级的软实时分布式数据存储系统，支持冗余复制和事务。 建立项目数据库 12345678建立数据库的过程可分为以下几个步骤：1、初始化mnesia2、启动节点3、建立数据库模式（schema)4、启动Mnesia5、建立数据库表6、向新建的表中录入数据7、对数据做一些基本查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687881、启动节点% 启动时告诉节点应该将Mnesia的相关信息写到文件系统的某个地方，由dir指定路径werl -mnesia dir '&quot;F:/erl/gen_server/mnesia/mnesia_store&quot;' -sname nodename2、建立数据库模式 (在本节点建立数据库模式)mnesia:create_schema([node()]).3、启动Mnesiamnesia:start().% 查看信息mnesia:info().4、建表-record(user,{ id, name}).-record(project,{ title, description}).-record(contributor,{ user_id, project_title}).init_tables() -&gt; mnesia:create_table(user,[{attributes,record_info(fields,user)}]), mnesia:create_table(project,[{attributes,record_info(fields,project)}]), mnesia:create_table(contributor,[{type,bag},{attributes,record_info(fields,contributor)}]). insert_user(Id,Name,ProjectTitles) when ProjectTitles =/= [] -&gt; User = #user{id =Id,name = Name}, F = fun() -&gt; mnesia:write(User), lists:foreach(fun(Title) -&gt; [#project{title = Title}] = mnesia:read(project,Title), mnesia:write(#contributor{user_id = Id,project_title = Title}) end,ProjectTitles) end, mnesia:transaction(F); %% 设置事务insert_user(_,_,_) -&gt; ok. insert_project(Title,Desc) -&gt; % 脏操作在执行时不会考虑事务或数据库锁 mnesia:dirty_write(#project{title = Title,description = Desc}).5、向表中录入数据mnesia:write(#user{id= Id,name = Name})% 脏操作mnesia:dirty_write(#project{title = Title,description = Desc})6、执行基本查询mnesia:read(project,Title).mnesia:dirty_read(user,1).F = fun() -&gt; mnesia:select(user,[{#user{id = '$1',name = abc},[],['$1']}]) end, mnesia:transaction(F).% mnesia:select/2% 第一个参数是待查询的表% 第二个参数是所有的匹配规范，每条匹配规范都是一个形如{Head,Conditions,Results}的三元组% Head是一个Erlang项式，用于描述查询模式，其中‘$1’,'$2'等原子用于表示变量。% Conditions部分用于罗列作用于该匹配条件上的额外约束条件% Results,可以描述要从匹配到的每条记录中生成什么样的结果项式% 一些具有特殊含义的原子：% ’_‘ (仅限于在Head部分使用) ------无所谓，任意值都可以% '$_' (仅限于在Results和Conditions中使用) --------与查询条件项匹配的整条记录% ’$$‘ (仅限于在Results和Conditions中使用) --------等价于依次罗列出在Head部分匹配的所有变量’$1‘,'$2'...等% 使用查询列表速构（QLC)mnesia:transaction(fun() -&gt; Table = mnesia:table(user), QueryHandle = qlc:q([U#user.id||U &lt;- Table，U#user.name =:= abc]), qlc:eval(QueryHandle) end)。 Mnesia表可分为set型，ordered_set型和bag型： set型：set型表中的建是唯一的，如果插入新的记录与先存的某个表项的主键相同，则新的记录会覆盖旧记录。 ordered_set型：ordered_set型与set型的行为相同，但set型表和bag型表都采用哈希表实现，ordered_set表则可以按主键的顺序保存记录。 bag型：bag型表可以容纳多个具有相同主键的记录，但这些记录至少要有一个字段的值不相等，同一条记录插入多次是没用的 创建发布镜像1、确定需要包含哪些应用 2、创建用于描述发布镜像内容的元数据（.rel）文件 3、创建启动脚本 4、创建系统配置文件（可选，但一般都需要） 5、将所有内容打包成单个文件 I、发布镜像的元数据文件（如：mnesia_sc.rel） {release,{发布镜像名,版本号},{erts,版本号},[{依赖的应用名,版本号}|…]} 12345678910{release, {&quot;mnesia_sc&quot;, &quot;0.1.0&quot;}, {erts, &quot;8.3&quot;}, [{kernel, &quot;5.2&quot;}, {stdlib, &quot;3.3&quot;}, {sasl, &quot;3.0.3&quot;}, {mnesia, &quot;4.14.3&quot;}, {resource_discovery, &quot;0.1.0&quot;}, {mnesia_sc, &quot;0.3.0&quot;} ]}. II、脚本与启动文件 .script文件内包含一份完整的规范，所有应用的内容明细全部都罗列在内，包括应用的路径、需要加载的模块，以及其他信息。 .boot文件则是.script文件的二进制形式，可供Erlang运行时系统在启动时直接读取。 生成这两个文件的操作： 123456789% 在.rel同目录下 执行erl -pa ./mnesia_sc/ebin -pa ./resource_discovery/ebin% 调用systools模块来生成真正的.boot和.script文件systools:make_script(&quot;mnesia_sc&quot;,[local])% 执行完命令后，当前目录下就会生成两个文件：mnesia_sc.script、mnesia_sc.boot% local参数主要用于测试，在调用make_script/2函数时，传入的local选项的作用在于将所有应用的绝对路径写入.script和.boot文件% 如果不采用local选项，生成的.script和.boot文件会认为所有应用都位于文件系统的某个名为lib的目录下,该目录的具体位置由系统变量$ROOT指定 III、系统配置 在.rel同目录下，穿件xxx.config文件 （xxx可以随便起名） [{应用名,[应用选项键值对]}|…] 123456789101112[ {sasl, [ {sasl_error_logger,{file,&quot;F:/erl/gen_server/test_pack/tmp/mnesia_sc.sasl_log&quot;}} ] }, {mnesia_sc, [ {contact_nodes,['a@SD-20190726VNMA','b@SD-20190726VNMA']} ] }]. III、启动柜目标系统 123456% 按照之前的缓存系统，至少启动一个联络节点a,然后再执行erl -sanme cache -boot ./mnesia_sc -config ./sys% -boot指定使用哪个.boot文件，这里是当前目录下的 mnesia_sc.boot% -config指定使用哪个.config文件，这里是当前目录下的 sys.config 可使用 observer:start() 查看起来的应用 12erl -sanme cache -boot ./mnesia_sc -config ./sys -detatched% 采用这种方式启动的系统将在后台运行，不会打开shell.在联络节点的shell内调用nodes()，仍然可以在结果中看到分离的节点，可以针对该节点启动一个远程shell来对它执行各种操作。","link":"/2024/03/19/Mnesia/"},{"title":"MySQL数据库","text":"数据库的范式​ 我们常见的也就三范式： ​ 一个数据库设计如果符合第二范式（2NF），一定也符合第一范式(1NF)。如果符合第三范式(3NF)，一定也符合第二范式(2NF)。 ​ 那么下面我们就来了解什么叫做数据库的范式吧~ 1NF：属性不可再分（强调的是列的原子性，即列不能够再分成其他几列） 2NF：属性完全依赖于主键（表中必须要有一个主键，表中的其他列（除主键列外）必须完全依赖于主键，而不能只依赖于主键的部分） 3NF : 属性不依赖于其他非主属性（消除传递依赖，确保每列都和主键列直接相关，而不是间接相关） 数据库ACID 原子性 原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。 一致性 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。 隔离性 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复 并发一致性问题 丢失修改 T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 脏读 （针对未提交数据）脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 解决方法：把数据库的事务隔离级别调整到 READ_COMMITTED 不可重复读 同时操作，事务1分别读取事务2操作时和提交后的数据，读取的记录内容不一致。不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 解决方法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。把数据库的事务隔离级别调整到REPEATABLE_READ 幻读 事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 （和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致） 解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题。把数据库的事务隔离级别调整到 SERIALIZABLE_READ mysql事务 事务例子：A向B转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来一样【A账户的钱没变，B账户的钱也没变】 ​ 如果没有添加事务，当A的钱减少的时候出现异常，而B并没有接受到A的转账 ​ 解决的方法： 1234567891011121314151617181920try{ //开启事务，对数据的操作就不会立即生效 connection.setAutoCommit(false); ...a执行减操作 ....出现问题 int a = 10/0; ...b执行加操作 //如果执行到这里，没有抛出异常，就提交数据 connection.commit(); //关闭事务，设置回原始的状态 connection.setAutoCommit(true); }catch(SQLException e){ try{ //如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】 connection.rollback(); //关闭事务，设置回原来的状态 connection.setAutoCommit(true); }catch(SQLException e1){ e1.printStackTrace(); } } 注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的 事务的隔离级别 数据库定义了4个隔离级别： Serializable（串行化）【可避免脏读，不可重复读，虚读】 Repeatable read（可重复读）【可避免脏读，不可重复读】 Read committed（读已提交）【可避免脏读】 Read uncommitted（读未提交）【级别最低，什么都避免不了】 分别对应 TRANSACTION_SERIALIZABLE TRANSACTION_REPEATABLE_READ TRANSACTION_READ_COMMITTED TRANSACTION_READ_UNCOMMITTED 本文参考https://frank-lam.github.io/fullstack-tutorial/#/MySQL","link":"/2019/08/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"php笔记","text":"PHP是一门弱类型语言(PHP: Hypertext Preprocessor) php基本语法： 12345678910&lt;?php //php代码 //echo与print的区别都是打印语句，echo可以同时打印多个字符串，prin只能打印一个 //echo打印之后没有返回值，print始终会返回一个1 echo &quot;first line code&quot;; // echo &quot;test1&quot;,&quot;test2&quot; print &quot;hello world&quot;;?&gt;php 脚本以&lt;?php 开始， 以 ?&gt; 结束php文件通常包含HTML标签和一些PHP脚本代码 注释： // 单行 /* * 多行注释 */ 大小写敏感： 12在PHP中，所有用户定义的函数、类和关键字（例如if、else、echo等）都对大小写不敏感不过在PHP中，所有变量都会对大小写敏感 变量： * 以$符号开始，后面接变量名称：$age (变量名称区分大小写 ,$Age 是另一个变量) * 变量名只能包含字母、数字和下划线 变量作用域： local (局部) // 如在方法内定义的变量即为局部变量（变量前面若有 global则为全局变量） global（全局） // 函数内调用函数外定义的全局变量，需要在函数内变量前加上global关键字 12345678910111213141516171819&lt;?php $x = 1; $y = 2; function test(){ global $x,$y; $y = $x + $y; //对全局变量$y 进行了新的赋值 }?&gt;另一种写法// PHP将所有全局变量存储在一个名为$GLOBALS[index]的数组中，index保存变量的名称， 这个数组可以在函数内部访问，也可以直接用来更新全局变量&lt;?php $x = 1; $y = 2; function test(){ $GOLBALS['y'] = $GLOBALS['x'] + $GLOBALS['y']; //对全局变量$y 进行了新的赋值 }?&gt; static （静态） 1234567891011&lt;?php function test(){ static $x = 0; echo $x; $x++; //静态变量进行加1 echo PHP_EOL //换行符 } test(); // echo 0 test(); // echo 1 test(); // echo 2?&gt; 如在一个方法内定义了一个静态变量(对变量进加1），那么每一次调用这个方法的时候，都是从之前的基础上进行加 1 parameter(参数作用域) // 方法的形参与实参 参数是通过调用代码将值传递给函数的局部变量。 参数是在参数列表中声明的，作为参数声明的一部分 数据类型： * String(字符串) //使用&quot;.&quot;（并置运算符）用于把两个字符串值连接起来。字符串可以使用单引号或双引号 * Integer(整型) * Float(浮点型) * Boolean(布尔型) * Array(数组) * Object(对象) * NULL(空值) 类型比较 (注意 0 、false、null 这三者的比较) * 使用两个等号'=='比较，只比较值，不比较类型 * 使用三个等号'==='比较，比较值，也比较类型 常量： 常量值被定义后，在脚本的其他任何地方都不能被改变 常量的命令规则与变量一样，但不需要在前面加上$ 符号 设置常量使用define()函数 12345678bool define(string $name, mixed $value [, bool $case_insensitive = false])name :必选参数，常量名称value：必选参数，常量值case_insensitive: 可选参数，如果设置为TRUE,该常量大小写不敏感。默认是大小写敏感例子：define(&quot;GREETING&quot;, &quot;Welcome&quot;); 顺序语句： * if.....elseif....else语句 * switch语句 循环语句： * while语句 * do....while语句 * for 语句 * foreach语句 数组（Array）（详解）： 1、在PHP中，有三种类型的数组： 数值数组 - 带有数字索引的数组 1234&lt;?php$cars = array(&quot;Volvo&quot;, &quot;BMW&quot;, &quot;Toyota&quot;);?&gt;// 可通过下标访问,获取数组长度count($cars) 关联数组 - 带有指定键的数组，每个键关联一个值 123456789&lt;?php $age = array(&quot;Peter&quot; =&gt; &quot;35&quot;, &quot;Ben&quot; =&gt; &quot;37&quot;, &quot;Joe&quot; =&gt; 18); //遍历数组 foreach($age as $x =&gt; $x_value){ echo &quot;key=&quot;. $x .&quot;, value= &quot;. $x_value; echo &quot;&lt;br&gt;&quot; }?&gt;$age['Peter'] // 可通过键去访问 多维数组 - 包含一个或多个数组的数组 * todo 2、数组排序 * sort() //对数组进行升序排序 * rsort() //对数组进行降序排序 * asort() //根据关联数组的值，对数组进行升序排序 * ksort() //根据关联数组的键，对数组进行升序排序 * arsort() //根据关联数组的值，对数组进行降序排序 * krsort() //根据关联数组的值，对数组进行降序排序 PHP超级全局变量：（在全部作用域中始终可用的内置变量） PHP中预定义了几个超级全局变量（superglobals）, 在一个脚本的全部作用域都可以用，不需要特别说明，就可以在函数及类中使用 $GLOBALS $_SERVER //用于保存关于报头、路径和脚本位置的信息 1234567891011如在表单中&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]); ?&gt;&quot;&gt;$_SERVER[&quot;PHP_SELF&quot;]是超级全局变量，返回当前正在执行脚本的文件名htmlspecialchars()函数把一些预定义的字符转换为HTML实体 * &amp;（和号） 成为 &amp;amp; * &quot;（双引号） 成为 &amp;quot; * ' (单引号) 成为 &amp;#039; * &lt; (小于) 成为 &amp;lt; * &gt; (大于) 成为 &amp;gt; $_REQUEST //用于收集HTML表单提交的数据 如：$name = $_REQUEST[‘name’]; 预定义的$_REQUEST变量包含了$_GET、$_POST、$_COOKIE的内容。 $_REQUEST变量可用来收集通过GET和POST方法发送过来的表单数据。 $_POST // 用于收集表单数据（post方法提交的表单） $_GET 用于收集表单数据（get方法提交的表单） $_FILES $_ENV $_COOKIE $_SESSION PHP 魔术常量： 这些常量是由不同的扩展库定义的，只有在加载这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了 __LINE__ //文件中的当前行号 __FILE__ //文件的完整路径和文件名，如果用在被包含文件中，则返回被包含的文件名 __DIR__ // 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录 __FUNCTION__ // 显示方法名 __CLASS__ // 显示类名 __METHOD__ // 显示方法名 __NAMESPACE__ // 显示命令空间 命名空间： todo PHP面向对象 类使用class关键字后加上类名定义 类名后一对大括号，里面定义成员变量以及成员方法 类的变量使用var进行声明，变量也可以初始化值 123456789101112131415161718192021222324&lt;?php class Site{ /* 成员变量 */ var $url var $title; /*成员函数*/ function setUrl($par){ $this-&gt;url = $par; } function getUrl(){ echo $this.url.PHP_EOL; //输入url并拼接一个换行符 } .... .... }?&gt;//创建对象$mysite = new Site()//调用方法$mysite-&gt;getUrl() 构造方法 1void __construct(...) //可以设置多个参数 析构函数 析构函数与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数 1void __destruct(void) 继承 PHP跟java一行不支持多继承（关键字 extends） 方法重写 从父类继承的方法不满足子类的需求，对其方法进行修改，这个过程称为覆盖（override） 访问控制 PHP对属性或方法的访问控制，是通过在前面添加关键字public（共有）， protected(受保护)，private(私有) public : 共有的类成员可以在任何地方被访问 protected: 受保护的类成员则可以被其自身以及其子类和父类访问 private: 私有的类成员则只能被其定义所在的类访问 被protected及private声明的变量、方法无法通过对象直接调用，会抛出错误，这是没有访问权限 可以在对象内部中定义一个普通的共有方法，在该方法里面调用protected、private修饰的变量、方法 接口 使用接口（interface）, 可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容 要实现一个接口，使用implements操作符，类中必须实现接口中定义的所有方法，类可以实现多个接口，用逗号来分隔多个接口的名称 1234567891011121314151617181920212223242526&lt;?php 声明一个接口 interface iTemplate{ public function setVariable($name,$var); public function getHtml($template); } //实现接口 class Template implements iTemplate{ private $vars = array(); //定义一个空数组 public function setVariable($name, $var) { $this-&gt;vars[$name] = $var; // 将传进来的值，存入关联数组中 } public function getHtml($template) { foreach($this-&gt;vars as $name =&gt; $value) { //关联数组获取值 $template = str_replace('{' . $name . '}', $value, $template); } return $template; }?&gt; 常量 12345类中声明一个常量const constant = '常量值' //不可变的值可通过类名或对象直接调用类名::constant // :: 这个符号用来调用常量 抽象类 如果一个类里面至少有一个方法被声明为抽象的，那么这个类就必须声明为抽象的 定义为抽象的类不能被实例化 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法，另外，这些方法的访问控制必须和父类中一样（或者更为宽松） 12345678910111213141516171819&lt;?php abstract class AbstractClass{ abstract protected function getvalue(); abstract protected function prefixValue($prefix); //普通的方法 public function printOut(){ print $this-&gt;getvalue().PHP_EOL; } } class ConcreteClass extends AbstractClass{ protected function getValue(){ return &quot;xxxxxxx&quot; } public function prefixValue($prefix){ return &quot;xxxxxxxxxx&quot; } }?&gt; 子类方法可以包含父类抽象方法中不存在的可选参数。 子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的 Static关键字 声明类属性或方法为static(静态)，就可以不实例化类而直接访问 静态属性不能通过一个类已实例化的对象来访问（但静态方法可以） 由于静态方法不需要通过对象即可直接调用，所以伪变量$this在静态方法中不可用 静态属性不可以有对象通过-&gt;来访问 1234567891011&lt;?php class Foo { public static $my_static = 'foo'; public function staticValue(){ return self::$my_static; } } print Foo::$my_static.PHP_EOL;?&gt; Final关键字 如果父类中的方法被声明为final，则子类无法覆盖该方法，如果一个类被声明为final，则不能被继承 调用父类构造方法 PHP不会在子类的构造方法中调用父类的构造方法。要执行父类的构造方法，需在子类的构造方法中调用parent::__construct() 高级​ PHP include 或 require语句，可以将PHP文件的内容插入另一个PHP文件 ​ include 和 require语句是相同的，除了错误处理方面： require会生成致命错误并停止脚本 include只会生成警告，并且脚本会继续运行 ​ PHP文件： readfile()函数读取文件，并把它写入输出缓存 文件打开/读取 123456789101112131415161718&lt;?php $myfile = fopen(&quot;filename.txt&quot;,&quot;r&quot;) or die(&quot;Unable to open file!&quot;); echo fread($myfile, filesize(&quot;filename.txt&quot;)) fclose($myfile);?&gt;读取文件-fread() fread()的第一个参数包含待读文件名，第二个参数规定待读取的最大字节数 关闭文件-fclose()读取单行文件- fgets()读取单字符-fgetc()检查 End-Of_file - feof() feof()函数检查是否已到达&quot;end-of-file&quot; (EOF) feof()对于遍历未知长度的数据很有用 文件创建/写入 123456789# 创建文件，并写入$myfile = fopen(&quot;filename.text&quot;, &quot;w&quot;) or die(&quot;Unable to open file&quot;);$txt = &quot;string&quot;;fwrite($myfile, $txt);fclose($myfile);写入文件-fwrite() fwrite()的第一个参数：要写入文件的文件名，第二个参数：被写的字符串 文件上传 1234567891011&lt;?php if($_FILES[&quot;file&quot;][&quot;error&quot;]&gt;0){ echo &quot;Error:&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br/&gt;&quot;; }else{ echo &quot;Upload:&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br/&gt;&quot;; echo &quot;Type:&quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br/&gt;&quot;; echo &quot;Size&quot; . ($_FILEs[&quot;file&quot;][&quot;size&quot;] /1024) . &quot;Kb&lt;br/&gt;&quot;; echo &quot;store in:&quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; }?&gt; cookie and session 1234567891011121314151617181920212223242526272829设置cookie setcookie(name,value,expire, path, domain);获取cookie $_COOKIE[name] php 用到sessioin必须先开启会话(session)&lt;?php session_start(); ?&gt;存储Session变量&lt;?php session_start(); //store session data $_SESSION['views'] = 1;?&gt;&lt;html&gt; &lt;body&gt; &lt;?php //retrieve session data echo &quot;pageviews=&quot;. $_SESSION['views']; ?&gt; &lt;/body&gt;&lt;/html&gt;销毁session&lt;?php unset($_SESSION['views']); //or session_destroy(); // lost all session?&gt; php 发送电子邮件 1mail(to(接受者), subject（主题）, message（消息）, headers, parameters) 过滤器（Filter）: * filter_var() 通过一个指定的过滤器来过滤单一的变量 * filter_var_array() 通过相同的或不同的过滤器来过滤多个变量 * filter_input 获取一个输入变量，并对它进行过滤变量 * filter_input_array() 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤 PHP连接MySQL数据库12345678910111213141516171819202122232425262728293031323334353637383940414243语法mysqli_connect(host, username, password, dbname)创建数据库&lt;?php$con = mysqli_connect(&quot;127.0.0.1&quot;, &quot;abc&quot;, &quot;123456&quot;);if(mysqli_connect_errno($con)){ echo &quot;Failed to connect to MySQL:&quot;. mysqli_connect_error();}$sql = &quot;CREATE DATABASE test_db&quot;;if(mysqli_query($con,$sql)){ echo &quot;Database my_db created successfully&quot;}else{ echo &quot;fail:&quot; . mysqli_error($conn);}//关闭连接mysqli_close($con);?&gt;===========================&lt;?php$con = mysqli_connect(&quot;127.0.0.1&quot;, &quot;abc&quot;, &quot;123456&quot;, &quot;test_db&quot;);if(mysqli_connect_errno($con)){ echo &quot;Failed to connect to MySQL:&quot;. mysqli_connect_error();}//创建数据表$sql = &quot;create table Persons(FirstName char(30), LastName char(30), Age INT)&quot;;if(mysqli_query($con,$sql)){ echo &quot;crate table success&quot;;}else{ echo &quot;fail&quot; . mysqli_error($con);}//关闭连接mysqli_close($con);?&gt; 杂项htmlspecialchars()函数把特殊字符转换为HTML实体。这意味着&lt; 和 &gt; 之类的HTML字符会被替换为$lt;和$gt; 基本的错误处理：使用die()函数","link":"/2024/02/12/PHP/"},{"title":"Servlet笔记","text":"http：http请求：一个完整http请求应该包含三个部分： 请求行【描述客户端的请求方式、请求的资源名称，以及使用的HTTP协议版本号】 多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】 一个空行 http响应：一个完整的HTTP响应应该包含四个部分: 一个状态行【用于描述服务器对请求的处理结果。】 多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】 一个空行 实体内容【服务器向客户端回送的数据】 何为ServletServlet是sun公司提供的一门用于开发动态web资源的技术 用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1. 编写一个Java类，实现servlet接口。 2. 把开发好的Java类部署到web服务器中。 Servlet的运行过程Servlet程序室友Web服务器调用，Web服务器接受到客户端的Servelt访问请求后： Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步。 2. 装载并创建该Servlet的一个实例对象。 3. 调用Servlet实例对象的init()方法。 4. 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 5. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 Servlet生命周期： 访问地址 –&gt; WEB-INF –&gt; web.xml –&gt; –&gt; 执行servlet 生命周期： init()(第一次访问servlet才会调用) service() destory()（关闭服务器则调用该方法或长时间不用tomcat自动销毁） 1231.被创建，执行且只执行一次init方法2.提供服务，执行service方法，执行多次3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。 注意：只要有首次访问Servlet才创建目标 Servlet调用图 一个Servlet的创建例子1234567891011121314151617181920212223public class ServletDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.01 Transitional//EN\\&quot;&gt;&quot;); out.println(&quot;&lt;HTML&gt;&quot;); out.println(&quot; &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;); out.println(&quot; &lt;BODY&gt;&quot;); out.print(&quot;Hello World!!!&quot;); out.println(&quot; &lt;/BODY&gt;&quot;); out.println(&quot;&lt;/HTML&gt;&quot;); out.flush(); out.close(); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } web.xml需要配置上servlet的映射 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.heclam.ServletDemo&lt;/servlet-class&gt;&lt;!--这里写类的全限定名--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--这里需要与上面Servlet-name一致 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!--这里是要输入什么才能访问到ServletDemo的映射--&gt; &lt;url-pattern&gt;/ServletDemo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 注意：&lt;servlet-mapping&gt;可以设置多个，这个我们就有多个映射路径可以访问到ServletDemo了 用servletContext实现请求转发1234567891011121314151617public class ServletDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取ServletContext对象 ServletContext context = this.getServletContext(); //获取请求转发对象 RequestDispatcher rd = context.getRequestDispatcher(&quot;/ServletDemo2&quot;); //调用forward方法实现请求转发 rd.forward(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... } } 转发（forward）和重定向（redirect）:​ 转发为在服务器里面操作，跳转到另一个servlet,它的地址栏没有改变，可以获取原来的数据，因为这是同一个request、response的http ​ 重定向：浏览器发送请求给服务器，服务器让浏览器去找其他的服务器于是浏览器又发了一条请求给其他路径的服务器，请求地址栏发生了改变（如果在地址栏里面带参数的话，是可以在服务器获取的）","link":"/2019/07/08/Servlet%E7%AC%94%E8%AE%B0/"},{"title":"Session笔记","text":"何为Session在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器中，这就是Session。 Session与Cookie的区别 Cookie是把用户的数据写给用户的浏览器 Session技术把用户的数据写到用户独占的Session中 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象 Cookie保存在浏览器中，Session保存在服务器中 有了Cookie为何还要使用Session呢Session比Cookie使用方便，Session可以解决Cookie解决不了的事情，比如：Session可以存储对象而Cookie只能存储字符串。 Session的实现原理服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务 SessionAPI 方法 描述 long getCreationTime() 获取Session被创建时间 String getId() 获取SessionId long getLastAccessedTime() 返回Session最后活跃的时间 ServletContext getServletContext() 获取ServletContext对象 void setMaxInactiveInterval(int var) 设置Session超时时间 int getMaxInactiveInterval() 获取Session超时时间 Object getAttribute(String var) 获取Session属性 Enumeration getAttributeNames() 获取Session所有的属性名 void setAttribute(String var1, Object var2) 设置Session属性 void removeAttribute(String var) 移除Session属性 void invalidate() 销毁该Session boolean isNew(); 该Session是否为新的 一个Session的例子1234567891011121314151617181920212223242526public class SessionDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setCharacterEncoding(&quot;UTF=8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); //使用request对象的getSession()获取session，如果session不存在则创建一个 HttpSession session = request.getSession(); //将数据存储到session中 session.setAttribute(&quot;data&quot;, &quot;heclam&quot;); //获取session的Id String sessionId = session.getId(); //判断session是不是新创建的 if (session.isNew()) { response.getWriter().print(&quot;session创建成功，session的id是：&quot;+sessionId); }else { response.getWriter().print(&quot;服务器已经存在该session了，session的id是：&quot;+sessionId); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } Session也是一个域对象，Session作为一种记录浏览器状态的机制，只要Session对象没有被销毁，Servlet之间就可以通过Session对象实现通信 1234//使用request对象的getSession()获取session，如果session不存在则创建一个 HttpSession session = request.getSession();//获取存入Session的属性 String val = session.getAttribute(&quot;data&quot;);","link":"/2019/07/08/Session%E7%AC%94%E8%AE%B0/"},{"title":"Spring事务管理","text":"事务的四个特性（ACID）： 原子性：原子性是指事务是一个不可分割的工作单位，事务里面的操作要么都发生，要么都不发生，如果有一个操作失败，事务将回滚 一致性：一致性指事务前后数据的完整性必须保持一致（事务执行的前后都是合法的数据状态，不会违背任何的数据完整性） 隔离性：隔离性指多个用户并发访问数据库时，一个用户的事务不被其他用户的事务所干扰，多个并发事务之前要相互隔离 持久性：持久性是指一个事务一旦被提交，那么数据就一定会被写入到数据库中并持久储存起来（事务被提交之后无法再回滚） 事务的属性传播行为（propagation）：传播行为定义了客户端与被调方法见的事务边界 PROPAGATION_REQUIRED：默认传播行为，指的是若当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务 PROPAGATION_REQUIRES_NEW：需要创建一个新的，若当前有事务，则将当前事务挂起。 PROPAGATION_SUPPORTS： 当前存在事务，就在事务中运行；当前不存在事务，则不在事务中运行。 PROPAGATION_NOT_SUPPORTED: 不运行在事务中，当前有事务，则挂掉当前事务。 PROPAGATION_NEVER：不运行在事务中，如果当前有事务，则抛出异常。 PROPAGATION_MANDARORY: 必须运行在事务中，如果当前方法没有事务，则抛出异常。 PROPAGATION_NESTED: 当前存在事务，则创建一个事务作为当前事务的嵌套事务运行，如果当前没有事务，则创建一个新的事务。 **隔离级别（isolation）:**指若干个并发事务之间的隔离程度 默认（DEFAULT） READ_UNCOMMITTED：读未提交，一个事务可以读取到另一个事务未提交的数据。（脏读，不可重复读，幻读）。 READ_COMMITTED：读已提交，一个事务只能读取另一个事务已经提交的数据。（不可重复读，幻读）。 REPEATABLE_READ：可重复读一个事务在整个过程中多次重复执行某个查询，每次返回的结果都相同。（幻读） SERIALIZABLE：序列化所有事务依次逐个执行，这样事务之间不可能存在干扰。 隔离引发的一些问题： 脏读：一个事务读取了另一个事务改写但未提交的数据 不可重复读（侧重于修改）：一个事务执行多次的读操作，每次得到不同数据。（并发访问造成的，可能另外一个事务已经对数据进行了更改） 幻读（侧重于新增或删除）：类似不可重复读。一个事务读取时遇到另一个事务的插入，则这个事务就会读取到一些原本不存在的记录。只读：事务只读时，数据库就可以对其进行一些特定的优化。事务超时：事务运行时间过长。回滚原则：定义那些异常会导致事务回滚。（默认情况只有运行时异常才事务回滚） Spring基于XML的声明式事务 Spring的声明式事务的支持是通过Spring AOP框架来实现的 123456789101112131415161718192021222324252627282930&lt;!-- 1.加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--2.配置数据源：有两个选择 c3p0,阿里的连接池druid--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--配置链接属性--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;/bean&gt; &lt;!--3.配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;...DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--4.配置事务通知，根据方法名，指定事务的属性--&gt;&lt;!--这是需要tx和aop的命名空间--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; propagation='&quot;SUPPORTS&quot;&gt; &lt;tx:method name=&quot;transferAc&quot; protagation=&quot;REQUIRED&quot;&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--5.配置aop,将事务和切入点关联起来--&gt;&lt;aop:config&gt; &lt;aop:pointcut expresssion=&quot;execution(* com.heclam.*(...))&quot; id=&quot;txPointcut&quot;&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; &lt;tx:advice&gt;实现声明事务性策略，所有的事务配置都在这里面， isolation:指定事务的隔离级别 propagation:指定事务的传播规则 read-only:指定事务为只读 使用&lt;tx:advice&gt;声明事务，需要一个事务管理器，这里定义了一个AOP的通知，然后还需要使用&lt;aop:config&gt;定义一个通知器（advisor）,里面还需定义一个切入点 Spring基于注解的声明式事务配置123456789101112131415161718192021222324252627282930&lt;!-- 1.加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--2.配置数据源：有两个选择 c3p0,阿里的连接池druid--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--配置链接属性--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;/bean&gt; &lt;!--3.配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;...DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--4.启动事务注解--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;以下的配置是在类中&lt;!--5.可以在对应的方法或类上添加Transaction注解--&gt;@Transactionpublic void transferAc(){}或者@Transactionpublic class Demo{ } 个人觉得还是基于注解的声明式事务比较简单些,不用做很多的配置","link":"/2019/08/14/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"title":"batch笔记","text":"参考传送门 常用命令1、echo 和 @ 回显命令 12345678910111213141516# 关闭单行回显@ # 从下一行开始关闭回显echo off # 从本行开始关闭回显，一般批处理第一行都是这个@echo off # 从下一行开始打开回显echo on # 表示输出空白行echo= # 表示此命令后的字符为注释，不执行rem 2、errorlevel echo %errorlevel% 每个命令行结束，都可以用这个命令行格式查看返回码（判断是否正常执行） 默认值为0，一般命令执行出错会设 errorlevel为1 3 、dir 显示文件夹内容 1234567891011121314151617#显示当前目录中的文件和子目录 dir #显示当前目录中的文件和子目录，包括隐藏文件和系统文件 dir /a #显示 C 盘当前目录中的目录dir c: /a:d #显示 C 盘根目录中的文件dir c: /a:-d #/b只显示文件名，/p分页显示 dir c: /b/p #显示当前目录和子目录里所有的.exe文件 dir *.exe /s 4、cd 切换目录 12345# 显示当前目录（当前路径）cd # 切换目录cd /d c:/abc 5、md 创建目录 12345# 如果目录不存在，将自动创建目录md f:\\notes\\abc # 在当前目录下创建文件夹md notes 6、rd 删除目录 12345# 删除当前目录里的 abc 子目录，要求为空目录 rd abc # 删除 f:\\notes文件夹及其子文件夹和文件，/q安静模式 rd /s/q f:\\notes 7、del 删除文件 12345678# 删除指定文件，不能是隐藏、系统、只读文件 del f:\\notes\\test.txt # 删除f:\\notes文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录 del /q/a/f f:\\notes\\\\*.\\* # 删除f:\\notes文件夹里面的所有文件，包括隐藏、只读、系统文件，包括子目录里面的文件del /q/a/f/s f:\\notes\\*.\\* 8、ren 重命名 12# 支持对文件夹的重命名ren f:\\notes\\test test2 9、cls 清屏 10、type 显示文件内容 12345# 显示指定文件的内容type f:\\notes\\a.txt # 显示当前目录里所有.txt文件的内容type *.txt 11、copy 拷贝文件 1234567891011# 复制test.txt文件为bb.txtcopy f:\\tt\\test.txt bb.txt # 从屏幕上等待输入，按Ctrl+z结束输入，输入内容存为a.txt文件，con代表屏幕copy con a.txt # 合并a.txt和b.txt的内容，保存为c.txt, 如果不指定 c.txt ，则保存到 a.txtcopy a.txt + b.txt c.txt # 复制文件到自己，实际上是修改了文件日期 copy a.txt + 12、title 设置cmd窗口的标题 12# 可以看到cmd窗口的标题栏变了 title 新标题 13、 pause 暂停命令 14、rem 和 :: 注释命令 注释行不执行操作 15、 date 和 time 日期和时间 1234567date # 显示当前日期，并提示输入新日期，按&quot;回车&quot;略过输入date/t # 只显示当前日期，不提示输入新日期time # 显示当前时间，并提示输入新时间，按&quot;回车&quot;略过输入time/t # 只显示当前时间，不提示输入新时间 16、goto 和 ： 跳转命令 123:lable # 行首为： 表示改行是标签行，标签行不执行操作goto lable # 跳转到指定的标签那一行 17、 find (外部命令) 查找命令 123456#在 c:test.txt 文件里查找含 abc 字符串的行 如果找不到，将设 errorlevel 返回码为1find &quot;abc&quot; c:test.txt find /i “abc” c:test.txt #查找含 abc 的行，忽略大小写find /c &quot;abc&quot; c:test.txt # 显示含 abc 的行的行数 18、 more (外部命令) 逐屏显示 1more c:test.txt #逐屏显示 c:test.txt 的文件内容 19、 tree 显示目录结构 1tree d: #显示D盘的文件目录结构 22、 &amp; 顺序执行多条命令，而不管命令是否执行成功 23、 &amp;&amp; 顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令 find &quot;ok&quot; c:test.txt &amp;&amp; echo 成功 如果找到了”ok”字样，就显示”成功”，找不到就不显示 24、 || 顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令 find &quot;ok&quot; c:test.txt || echo 不成功 如果找不到”ok”字样，就显示”不成功”，找到了就不显示 25、 |管道命令dir *.* /s/a | find /c &quot;.exe&quot;管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数type c:test.txt|more这个和 more c:test.txt 的效果是一样的 26、 &gt; 和 &gt;&gt;输出重定向命令 清除文件中原有的内容后再写入 追加内容到文件末尾，而不会清除原有的内容主要将本来显示在屏幕上的内容输出到指定文件中指定文件如果不存在，则自动生成该文件type c:test.txt &gt;prn屏幕上不显示文件内容，转向输出到打印机echo hello world&gt;con在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的copy c:test.txt f: &gt;nul拷贝文件，并且不显示”文件复制成功”的提示信息，但如果f盘不存在，还是会显示出错信息copy c:test.txt f: &gt;nul 2&gt;nul不显示”文件复制成功”的提示信息，并且f盘不存在的话，也不显示错误提示信息echo ^^W ^&gt; ^W&gt;c:test.txt生成的文件内容为 ^W &gt; W^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号 27 、&lt;从文件中获得输入信息，而不是从屏幕上一般用于 date time label 等需要等待输入的命令 12345@echo offecho 2005-05-01&gt;temp.txtdate &lt;temp.txtdel temp.txt# 这样就可以不等待输入直接修改当前日期 28、%0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*命令行传递给批处理的参数 1234567891011121314151617181920212223242526272829%0 批处理文件本身%1 第一个参数%9 第九个参数%* 从第一个参数开始的所有参数批参数(%n)的替代已被增强。您可以使用以下语法:%~1 - 删除引号(&quot; )， 扩充 %1%~f1 - 将 %1 扩充到一个完全合格的路径名%~d1 - 仅将 %1 扩充到一个驱动器号%~p1 - 仅将 %1 扩充到一个路径%~n1 - 仅将 %1 扩充到一个文件名%~x1 - 仅将 %1 扩充到一个文件扩展名%~s1 - 扩充的路径指含有短名%~a1 - 将 %1 扩充到文件属性%~t1 - 将 %1 扩充到文件的日期/时间%~z1 - 将 %1 扩充到文件的大小%~$PATH : 1 - 查找列在 PATH 环境变量的目录，并将 %1扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串可以组合修定符来取得多重结果:%~dp1 - 只将 %1 扩展到驱动器号和路径%~nx1 - 只将 %1 扩展到文件名和扩展名%~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1，并扩展到找到的第一个文件的驱动器号和路径。%~ftza1 - 将 %1 扩展到类似 DIR 的输出行。可以参照 call/? 或 for/? 看出每个参数的含意echo load &quot;%%1&quot; &quot;%%2&quot;&gt;c:test.txt生成的文件内容为 load &quot;%1&quot; &quot;%2&quot;批处理文件里，用这个格式把命令行参数输出到文件 29、 if判断命令 123456789101112if &quot;%1&quot;==&quot;/a&quot; echo 第一个参数是/aif /i &quot;%1&quot; equ &quot;/a&quot; echo 第一个参数是/a/i # 表示不区分大小写，equ 和 == 是一样的，其它运算符参见 if/?if exist c:test.bat echo 存在c:test.bat文件if not exist c:windows (echo 不存在c:windows文件夹)if exist c:test.bat (echo 存在c:test.bat) else (echo 不存在c:test.bat) 30 、setlocal 和 endlocal设置”命令扩展名”和”延缓环境变量扩充” 123456789101112SETLOCAL ENABLEEXTENSIONS #启用&quot;命令扩展名&quot;SETLOCAL DISABLEEXTENSIONS #停用&quot;命令扩展名&quot;SETLOCAL ENABLEDELAYEDEXPANSION #启用&quot;延缓环境变量扩充&quot;SETLOCAL DISABLEDELAYEDEXPANSION #停用&quot;延缓环境变量扩充&quot;ENDLOCAL #恢复到使用SETLOCAL语句以前的状态# “命令扩展名”默认为启用# “延缓环境变量扩充”默认为停用# 批处理结束系统会自动恢复默认值# 可以修改注册表以禁用&quot;命令扩展名&quot;，详见 cmd /? 。所以用到&quot;命令扩展名&quot;的程# 序，建议在开头和结尾加上 SETLOCAL ENABLEEXTENSIONS 和 ENDLOCAL 语句，以确# 保程序能在其它系统上正确运行# &quot;延缓环境变量扩充&quot;主要用于 if 和 for 的符合语句，在 set 的说明里有其实用例程 31、set 设置变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 引用变量可在变量名前后加 % ，即 %变量名%set #显示目前所有可用的变量，包括系统变量和自定义的变量echo %SystemDrive% #显示系统盘盘符。系统变量可以直接引用set p #显示所有以p开头的变量，要是一个也没有就设errorlevel=1set p=aa1bb1aa2bb2 #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2echo %p% #显示变量p代表的字符串，即aa1bb1aa2bb2echo %p:~6% #显示变量p中第6个字符以后的所有字符，即aa2bb2echo %p:~6,3% #显示第6个字符以后的3个字符，即aa2echo %p:~0,3% #显示前3个字符，即aa1echo %p:~-2% #显示最后面的2个字符，即b2echo %p:~0,-2% #显示除了最后2个字符以外的其它字符，即aa1bb1aa2becho %p:aa=c% #用c替换变量p中所有的aa，即显示c1bb1c2bb2echo %p:aa=% #将变量p中的所有aa字符串置换为空，即显示1bb12bb2echo %p:*bb=c% #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2set p=%p:*bb=c% #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2set /a p=39 #设置p为数值型变量，值为39set /a p=39/10 #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3set /a p=p/10 #用 /a 参数时，在 = 后面的变量可以不加%直接引用set /a p=”1&amp;0″ #”与”运算，要加引号。其它支持的运算符参见set/?set p= #取消p变量set /p p=请输入屏幕上显示”请输入”，并会将输入的字符串赋值给变量p注意这条可以用来取代 choice 命令注意变量在 if 和 for 的复合语句里是一次性全部替换的，如@echo offset p=aaaif %p%==aaa (echo %p%set p=bbbecho %p%)结果将显示aaaaaa因为在读取 if 语句时已经将所有 %p% 替换为aaa这里的&quot;替换&quot;，在 /? 帮助里就是指&quot;扩充&quot;、&quot;环境变量扩充&quot;可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!@echo offSETLOCAL ENABLEDELAYEDEXPANSIONset p=aaaif %p%==aaa (echo %p%set p=bbbecho !p!)ENDLOCAL结果将显示aaabbb还有几个动态变量，运行 set 看不到%CD% #代表当前目录的字符串%DATE% #当前日期%TIME% #当前时间%RANDOM% #随机整数，介于0~32767%ERRORLEVEL% #当前 ERRORLEVEL 值%CMDEXTVERSION% #当前命令处理器扩展名版本号%CMDCMDLINE% #调用命令处理器的原始命令行可以用echo命令查看每个变量值，如 echo %time%注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到 32、 start批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令 33、 call批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行有时有的应用程序用start调用出错的，也可以call调用 34、 choice (外部命令)选择命令让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……win98里是choice.comwin2000pro里没有，可以从win98里拷过来win2003里是choice.exechoice /N /C y /T 5 /D y&gt;nul延时5秒 35、 assoc 和 ftype文件关联assoc 设置’文件扩展名’关联，关联到’文件类型’ftype 设置’文件类型’关联，关联到’执行程序和参数’当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开而是先判断.txt属于 txtfile ‘文件类型’再调用 txtfile 关联的命令行 txtfile=%SystemRoot%system32NOTEPAD.EXE %1可以在”文件夹选项”→”文件类型”里修改这2种关联 123456789101112assoc #显示所有'文件扩展名'关联assoc .txt #显示.txt代表的'文件类型'，结果显示 .txt=txtfileassoc .doc #显示.doc代表的'文件类型'，结果显示 .doc=Word.Document.8assoc .exe #显示.exe代表的'文件类型'，结果显示 .exe=exefileftype #显示所有'文件类型'关联ftype exefile #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %*assoc .txt=Word.Document.8# 设置.txt为word类型的文档，可以看到.txt文件的图标都变了assoc .txt=txtfile# 恢复.txt的正确关联ftype exefile=&quot;%1&quot; %*# 恢复 exefile 的正确关联, 如果该关联已经被破坏，可以运行 command.com ，再输入这条命令 36、 pushd 和 popd 1234567#切换当前目录@echo offc: &amp; cd &amp; md mp3 #在 C: 建立 mp3 文件夹md d:mp4 #在 D: 建立 mp4 文件夹cd /d d:mp4 #更改当前目录为 d:mp4pushd c:mp3 #保存当前目录，并切换当前目录为 c:mp3popd #恢复当前目录为刚才保存的 d:mp4 37、 for循环命令这个比较复杂，请对照 for/? 来看for %%i in (c: d: e: f:) do echo %%i依次调用小括号里的每个字符串，执行 do 后面的命令注意%%i，在批处理中 for 语句调用参数用2个%默认的字符串分隔符是”空格键”，”Tab键”，”回车键”for %%i in (*.txt) do find &quot;abc&quot; %%i对当前目录里所有的txt文件执行 find 命令for /r . %%i in (*.txt) do find &quot;abc&quot; %%i在当前目录和子目录里所有的.txt文件中搜索包含 abc 字符串的行for /r . %%i in (.) do echo %%~pni显示当前目录名和所有子目录名，包括路径，不包括盘符for /r d:mp3 %%i in (*.mp3) do echo %%i&gt;&gt;d:mp3.txt把 d:mp3 及其子目录里的mp3文件的文件名都存到 d:mp3.txt 里去for /l %%i in (2,1,8) do echo %%i生成2345678的一串数字，2是数字序列的开头，8是结尾，1表示每次加1for /f %%i in ('set') do echo %%i对 set 命令的输出结果循环调用，每行一个for /f &quot;eol=P&quot; %%i in ('set') do echo %%i取 set 命令的输出结果，忽略以 P 开头的那几行for /f %%i in (d:mp3.txt) do echo %%i显示 d:mp3.txt 里的每个文件名，每行一个，不支持带空格的名称for /f &quot;delims=&quot; %%i in (d:mp3.txt) do echo %%i显示 d:mp3.txt 里的每个文件名，每行一个，支持带空格的名称for /f &quot;skip=5 tokens=4&quot; %%a in ('dir') do echo %%a对 dir 命令的结果，跳过前面5行，余下的每行取第4列每列之间的分隔符为默认的”空格”可以注意到 dir 命令输出的前5行是没有文件名的for /f &quot;tokens=1,2,3 delims=- &quot; %%a in ('date /t') do ( echo %%a echo %%b echo %%c )对 date /t 的输出结果，每行取1、2、3列第一列对应指定的 %%a ，后面的 %%b 和 %%c 是派生出来的，对应其它列分隔符指定为 - 和”空格”，注意delims=-后面有个”空格”其中tokens=1,2,3若用 tokens=1-3 替换，效果是一样的for /f &quot;tokens=2* delims=- &quot; %%a in ('date /t') do echo %%b取第2列给 %%a ，其后的列都给 %%b 38、 subst (外部命令)映射磁盘 123subst z: serverd #这样输入z:就可以访问serverd了subst z: /d #取消该映射subst #显示目前所有的映时 39、xcopy (外部命令)文件拷贝 123xcopy d:mp3 e:mp3 /s/e/i/y#复制 d:mp3 文件夹、所有子文件夹和文件到 e: ，覆盖已有文件#加 /i 表示如果 e: 没有 mp3 文件夹就自动新建一个，否则会有询问 常用DOS命令 文件夹管理 cd 显示当前目录名或改变当前目录 md 创建目录 rd 删除目录 dir 显示目录中的文件和子目录列表 tree 以图形显示驱动器或路径的文件夹结构 文件管理 type 显示文本文件的内容 copy 将一份或多份文件复制到另一个位置 del 删除一个或数个文件 move 移动文件并重命名文件和目录 ren 重命名文件 replace 替换文件","link":"/2024/02/21/batch%E7%AC%94%E8%AE%B0/"},{"title":"contab基础用法","text":"语法： 12345crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab { -l | -r | -e }-u #&lt;用户名称&gt; 是指设定指定&lt;用户名称&gt;的定时任务，这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话，就是表示设定自己的定时任务。-l #列出该用户的定时任务设置。-r #删除该用户的定时任务设置。-e #编辑该用户的定时任务设置。 命令时间格式 : 123456789* * * * * command分 时 日 月 周 命令第1列表示分钟1～59 每分钟用*或者 */1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令 一些Crontab定时任务例子: 12345678910111213141516171830 21 * * * /usr/local/etc/rc.d/lighttpd restart #每晚的21:30 重启apache45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart #每月1、10、22日的4 : 45重启apache10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart #每周六、周日的1 : 10重启apache0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart #每天18 : 00至23 : 00之间每隔30分钟重启apache0 23 * * 6 /usr/local/etc/rc.d/lighttpd restart #每星期六的11 : 00 pm重启apache* 23-7/1 * * * /usr/local/etc/rc.d/lighttpd restart #晚上11点到早上7点之间，每隔一小时重启apache* */1 * * * /usr/local/etc/rc.d/lighttpd restart #每一小时重启apache0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart #每月的4号与每周一到周三的11点重启apache0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart #一月一号的4点重启apache */30 * * * * /usr/sbin/ntpdate cn.pool.ntp.org #每半小时同步一下时间0 */2 * * * /sbin/service httpd restart #每两个小时重启一次apache 50 7 * * * /sbin/service sshd start #每天7：50开启ssh服务 50 22 * * * /sbin/service sshd stop #每天22：50关闭ssh服务 0 0 1,15 * * fsck /home #每月1号和15号检查/home 磁盘 1 * * * * /home/bruce/backup #每小时的第一分执行 /home/bruce/backup这个文件 00 03 * * 1-5 find /home &quot;*.xxx&quot; -mtime +4 -exec rm {} \\; #每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。30 6 */10 * * ls #每月的1、11、21、31日是的6：30执行一次ls命令","link":"/2024/03/16/crontab/"},{"title":"erlang Ets and Dets","text":"ETS和EDTSETS 和 DETS 表保存的是元组。 ETS 和 DETS 基本上做同一件事情：它们提供大量的“键-值” 搜索表，所不同的是，ETS驻留在内存，而DETS驻留在磁盘。 表的4种类型： set、ordered set、bag、 duplidate bag， 在set类型下，表中每一个元组的键值都不能相同。 在ordered set 类型下，元组会进行排序。 在bag类型下，多个元组可以有相同的键值，但不能有两个完成相同的元组。 在duplicate bag 类型下，不仅多个元组可以有相同的键值，同一个元组也可以在表中出现多次 12345678ets:new(Name, [Opt]) -&gt; TableId% Name 是一个原子% [Opt] 是一个选项列表，取值范围% 表类型 set| ordered_set | bag | duplicate_bag % private 创建私有表，只有所有者进程可以读写这个表% public 创建公开表，所有知道这个表标识的进程都可以对这个表进行读写操作% protected 创建受保护的表，所有知道这个表的标识的进程都可以对这个表进行读操作，但只有这个表的所有者进程可以对这个表进行写操作% named_table 命名表，如果存在这个选项，则可以在后续操作中使用Name来操作表 % {keypos, K} 使用K作为键的位置","link":"/2024/03/12/erlangEtsAndDets/"},{"title":"erlang Otp","text":"1、OTP 应用OTP(Open Telecom PlatForm) 开放电信平台 应用的目录结构如下 123456&lt;application-name&gt;[-&lt;version&gt;] - doc - ebin - include - priv - src 创建OPT应用时的主要工作集中于标准目录结构的创建和应用元数据的编写。元数据的作用在于让系统获悉应该如何启动和停止应用，还可以用于指定应用的依赖项，也就是应用启动前必须预先安装或启动哪些其他应用。 应用元数据 元数据一般为&lt;application-name&gt;.app 文件存放在server/ebin/文件夹下 12345678910111213%% tcp_rpc.app%% _*_ mode: Erlang; fill-column: 75; comment-column: 50; _*_{application, tcp_rpc, %% tcp_rpc为应用名称 [{description, &quot;RPC server for Erlang and OTP in action&quot;}, {vsn, &quot;0.1.0&quot;}, %% 应用版本 主版本号.次版本号.修订版本号 {modules, [tr_app, tr_sup, tr_server]},% 模块列表 {registered, [tr_sup]}, %% 注册进程名 {applications, [kernel, stdlib]}, %% 依赖其他应用的列表 {mod, {tr_app, []}} %% 告知OTP系统应该如何启动应用 ]}. 元数据文件&lt;application-name&gt;.app 文件的格式很简明。除去注释，只剩下一个由句号结尾的Erlang项式：三元组 {application, ..., ...}, 其中第二个元素是应用名称所对应的原子，此处即是tcp_rpc。第三个元素是一个参数列表，其中每一个参数都是{Key, Value}对的形式。 参数 描述 description 针对应用的简短描述 vsn 应用的版本 modules 应用中的模块列表。模块在列表中的顺序无关紧要 registered 在.app文件中罗列出所有进程注册名并不会促使系统执行实际的注册操作，但这可以告知OTP系统哪个进程注册了哪个名字，从而为系统升级等操作提供便利，同时也可以尽早发现重复的注册名并给出警告 applications 必须在该应用启动前先启动的所有应用。应用往往依赖于其他应用。主动应用要求自己所依赖的所有应用在自己的生命周期开始之前先行启动并就绪。列表中各应用的顺序无关紧要 mod 告知OTP系统应该如何启动应用。该参数的值是一个元组，其内容为一个模块名以及一些可选的启动参数。 这个模块必须实现application行为模式 应用行为模式 123456789101112131415161718-module(tr_app).-behaviour(application). % 行为模式声明% 应用行为模式的回调函数-export([ start/2, stop/1 ]).start(_Type, _StartArgs) -&gt; case tr_sup:start_link() of % 启动根监督者 {ok, Pid} -&gt; {ok, Pid}; Other -&gt; {error, Other} end.stop(_State) -&gt; ok. start/2的输入参数，Type一般取值为normal,但也可能是{failover, …} 或{takeover, …}, StartArgs 则是在元数据文件.app` 文件中给mod的参数 监督者行为模式 123456789101112131415161718-module(tr_sup).-behaviour(supervisor).%% API-export([start_link/0]).%% Supervisor callbacks-export([init/1]).-define(SERVER, ?MODULE).start_link() -&gt; supervisor:start_link({local, ?SERVER}, ?MODULE, []).init([]) -&gt; Server = {tr_server, {tr_server, start_link, []}, permanent, 2000, worker, [tr_server]}, Children = [Server], RestartStrategy = {one_for_one, 0, 1}, {ok, {RestartStrategy, Children}}. supervisor:start_link({local, ?SERVER}, ?MODULE, []) 第一个参数是二元组{local, ?SERVER}, 用于让OTP库在本地节点上以?SERVER(如宏定义为tr_sup)为注册名自动注册监督进程 3.1、监督者重启策略init/1 回调函数的返回值的格式为 {ok, {RestartStrategy, Children}}, 其中Children是若干子进程规范组成的一个列表。 RestartStrategy是一个三元组 {How, Max, Within} 3.2、子进程规范12Server = {tr_server, {tr_server, start_link, []}, permanent, 2000, worker, [tr_server]}, 由6个元素组成：{ID, Start, Restart, Shutdown, Type, Modules} 第一个元素ID, 是一个用于在系统内部标识规范的项式。 第二个元素Start, 是一个用于启动进程的三元组Module, Function, Arguments。与调用内置函数spawn/3 时是一样的，其中一个元素是模块名，第二个元素是函数名，第三个元素是函数的调用参数列表。 第三个元素Restart,用于指明子进程发生故障时是否需要重启。此处指定为permanent,无论出于任何原因导致进程终止都应重启进程。temporary 表示永不重启进程，transient 表示仅在进程意外终止时重启进程。 第四个元素Shutdown, 用于指明如何终止进程。此处取值为一个整数（2000），表示终止进程时采用软关闭策略，给进程留出一段自我了断的时间（以毫秒为单位），如果进程未能在指定时间内自行退出，将被无条件终止。该选项还可以取值为brutal_kill,表示在关闭监督进程时立即终止子进程；以及infinity, 主要用于子进程本身也同为监督者的情况，表示应给予子进程充分的时间自行退出 第五个元素Type，用于表示进程是监督者（supervisor)还是工作者（worker) 第六个元素Modules,选项列出了该进程所依赖的模块。这部分信息仅用于在代码热升级时告知系统该以何种顺序升级各个模块。一般来说，只需要列出子进程的主模块 启动应用 上面的tr_server.erl 模块就是一个gen_server 行为模式的实现为一个工作进程 123456789101112131415161718192021# 1、可以先进行代码编译# -o 表示指定编译后的.beam文件存放位置# src/*.erl表示需要编译的源代码erlc -o ebin src/*.erl# 2、代码执行的环境,(-pa 是path add 的缩写，用于添加单个目录到代码路径的最前方)erl -pa ebin# 3、Erlang shell 启动后，只需一个命令便可启动应用:# 以应用名tcp_rpc为参数调用标准库函数 application:start/1application:start(tcp_rpc).%%%====================================% 这里讲解一下如何运行这个项目% 将.beam文件放入ebin文件夹下% 1. windows：进入项目路径下然后在cmd下输入for %f in (src/*.erl) do erlc -o ebin src/%f% 2. linux：输入：erl -o ebin src/*.erl% 启动Erlang并将ebin目录纳入代码路径% 3. erl -pa ebin% 4. application:start(tcp_rpc)%%%==================================== Erlang会在代码路径中搜索.beam文件来加载模块，application:start/1函数也会在代码路径中搜索.app文件。由于ebin目录已经位于代码路径之中，shell便可以顺利找到元数据文件ebin/tcp_rpc.app，该文件包含了所需的一切信息（尤其是该调用哪个模块（tr_app)来启用整个应用） 生成EDoc文档 12%% 在项目目录下打开erl,输入edoc:application(tcp_rpc, &quot;.&quot;, []). 2、应用结构小结​ 建立OPT应用要做的3件事 1231. 遵循标准目录结构2. 添加用于存放应用元数据的.app文件3. 创建一个application行为模式实现模块，负责启动应用 3、监督树例子1234567891011121314151617181920212223242526272829-module(bank_sup).-behaviour(supervisor).-export([start_link/0]).-export([init/1]).% 定义一个启动本监督树的APIstart_link() -&gt; supervisor:start_link({local, ?MODULE}, ?MODULE, []).init([]) -&gt; % 启动两个子进程 BankCenterSpec = { center, % 指定本进程（在子进程中唯一）的名称 {bank_center, start_link,[]}, % 进程启动函数：{M,F,A} transient, % 重启策略： permanent | transient | temporary 5000, % 关闭方式： brutal_kill | init() &gt; 0 | infinity worker, % 进程类型： worker | supervisor [bank_center] % 回调模块名称： [Module] |dynamic }, BankCenterSpec2 = { center2, {bank_center2,start_link, []}, transient, 5000, worker, [bank_center2] }, % {ok, {{RestartStrategy, MaxR, MaxT}, [ChildSpec]}} {ok,{{one_for_one, 5, 30}, [BankCenterSpec,BankCenterSpec2]}}. 重启策略12345permanent : 终止后总是会被重启transient : 意外终止后会被重启（就是进程退出的Reason不是 normal | shutdown | {shutdown, Term}） temporary : 终止后不会被重启 如果重启策略为permanent，那么发生异常的系统进程就会不断地重启，这可如何是好？ {ok, {{RestartStrategy, MaxR, MaxT}, [ChildSpec]}}{ok, {{RestartStrategy, MaxR, MaxT}, [ChildSpec]}}可以很好的解决这个问题 RestartStrategy : 重启策略 one_for_one: 当某个进程终止时，只启动这个子进程 simple_for_one: 和one_for_one一样，只是子进程是监督树启动后在动态添加的，比如游戏中，一个玩家就是一个进程 one_for_all: 当某个进程终止时，全部的子进程都重新启动 rest_for_one: 但某个进程终止时，之前比它晚启动的进程都将重新启动 例如MaxR = 5 与MaxT = 30 表示在30秒内该进程总允许重启数为5，如果超过了，那么该进程将终止，整个监督树下的进程都将会终止，整个applicaiton也就此停止 子规范1234567891011121314{Id, StartFunc, Restart, Shutdown, Type, Modules}%------------------------------------{Id, StartFunc, Restart, Shutdown, Type, Modules} Id = term() StartFunc = {M, F, A} M = F = atom() A = [term()] Restart = permanent | transient | temporary Shutdown = brutal_kill | integer() &gt;=0 | infinity Type = worker | supervisor Modules = [Module] | dynamic Module = atom()%----------------------------------- Id 用来内部标识子规范 StartFunc是启动子进程时调用的函数，它将成为对supervisor:start_link, gen_server:start_link,gen_fsm:start_link,gen_event:start_link的调用 Restart标识一个进程终止后将怎样重启，一个permanent进程总会被重启；一个temporary进程不会被重启；一个transient进程仅仅当时不正常的被终止后才重启，例如非normal的退出原因 Shutdown定义一个进程怎样被终止，brutal_kill意味着子进程被exit(Child,kill) 无条件的终止；一个整数值的超时时间意味着监督者告诉子进程通过exit(Child, shutdown)而被终止，然后等待一个返回的退出信号，假如在指定时间里没有收到退出信号，那么子进程用exit(Child,kill)被无条件终止。 Type 指定子进程是supervisor还是worker Modules 是有一个元素的列表[Module],假如子进程时supervisor、gen_server或gen_fsm那么Module是回调模块的名称；假如子进程时gen_event,那么Modules应该是dynamic 4、另外一种编译方式在项目根目录下，新建一个Emakefile文件 12345678910111213{ [ 'src/*', 'src/*/*', 'src/*/*/*', 'src/*/*/*/*', 'src/*/*/*/*/*' ], [ {i, &quot;include/&quot;}, {outdir,'ebin'} ]}. 上面的结构一目了然，源码路径，头文件路径，输出目录 12% 在项目根目录下调用cmd窗口，执行一下命令编译erl -make 5、OTP中的缓存系统例子​ 简易缓存应用中的模块 ​ 模块 用途 ​ simple_cache 用户API,应用的外部接口 ​ sc_app 应用行为模式实现模块 ​ sc_sup 根监督者实现模块 ​ sc_store 用于封装键和pid之间映射关系的模块 ​ sc_element 缓存数据存储进程 搭建基本的骨架 12341. 创建标准应用目录布局（上面可见）；2. 编写.app文件；3. 编写应用行为模式实现，即sc_app;4. 实现顶层监督者，即sc_sup 创建应用元数据(ebin/simple_cache.app) 1234567891011{application, simple_cache, [{description, &quot;A simple caching system&quot;}, {vsn,&quot;0.1.0&quot;}, {modules,[ sc_app, sc_sup ]}, {registered, [sc_sup]}, {applications, [kernel, stdlib]}, {mod, {sc_app, []}} ]}. 实现应用行为模式(src/sc_app.erl) 123456789101112131415161718192021222324252627282930313233343536373839%%%-------------------------------------------------------------------%%% @author Administrator%%% @copyright (C) 2019, &lt;COMPANY&gt;%%% @doc%%%%%% @end%%% Created : 04. 十二月 2019 18:16%%%--------------------------------------------------------------------module(sc_app).-author(&quot;Administrator&quot;).% 实现应用行为模式-behaviour(application).%% API% 导出的行为模式回调函数-export([start/2, stop/1]).start(_StartType, _StartArgs) -&gt; sc_store:init(), % 存储初始化 case sc_sup:start_link() of % 启动根监督者 {ok, Pid} -&gt; {ok, Pid}; Other -&gt; {error, Other} end.stop(_State) -&gt; ok.%%%====================================% 这里讲解一下如何运行这个项目% 将.beam文件放入ebin文件夹下% 1. windows：进入项目路径下然后在cmd下输入for %f in (src/*.erl) do erlc -o ebin src/%f% 2. linux：输入：erl -o ebin src/*.erl% 启动Erlang并将ebin目录纳入代码路径% 3. erl -pa ebin% 4. application:start(simple_cache)% 5. simple_cache:insert(a,man). % 插入数据%%%==================================== 实现监督者（src/sc_sup.erl） 123456789101112131415161718192021222324252627282930313233343536%%%-------------------------------------------------------------------%%% @author Administrator%%% @copyright (C) 2019, &lt;COMPANY&gt;%%% @doc%%%%%% @end%%% Created : 04. 十二月 2019 18:21%%%--------------------------------------------------------------------module(sc_element_sup).-author(&quot;Administrator&quot;).% 实现监督者-behaviour(supervisor).%% API-export([start_link/0, start_child/2]). %% start_child/2 动态启动子进程-export([init/1]).-define(SERVER, ?MODULE).start_link() -&gt; supervisor:start_link({local, ?SERVER}, ?MODULE, []).start_child(Value, LeaseTime) -&gt; % sc_element:start_link/2的参数 supervisor:start_child(?SERVER, [Value, LeaseTime]).init([]) -&gt; %% 关闭策略设置为brutal_kill,表示子进程应随监督者的关闭而立即终止 Element = {sc_element, {sc_element, start_link, []}, temporary, brutal_kill, worker, [sc_element]}, Children = [Element], %% 监督策略，（简易一对一监督，只能启动一种子进程，但可以启动任意个） %% 它所有的子进程都是运行时动态添加的，子进程不会随监督者一同启动 %% 这里设置的重启频率为每秒0次（即不执行重启） RestartStrategy = {simple_one_for_one, 0,1}, {ok, {RestartStrategy, Children}}. 编写sc_element进程（src/sc_element.erl） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091%%%-------------------------------------------------------------------%%% @author Administrator%%% @copyright (C) 2019, &lt;COMPANY&gt;%%% @doc%%%%%% @end%%% Created : 04. 十二月 2019 19:44%%%--------------------------------------------------------------------module(sc_element).-author(&quot;Administrator&quot;).-behaviour(gen_server).%% API-export([ start_link/2, create/2, create/1, fetch/1, replace/2, delete/1]).-export([init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2,code_change/3]).-define(SERVER, ?MODULE).-define(DEFAULT_LEASE_TIME, (60*60*24)). % 一天的总秒数 , 默认的淘汰时间-record(state, {value, lease_time, start_time}). % 状态记录：进程持有值，淘汰时间，进程启动的时间戳start_link(Value, LeaseTime) -&gt; gen_server:start_link(?MODULE, [Value, LeaseTime],[]).create(Value, LeaseTime) -&gt; sc_sup:start_child(Value, LeaseTime). % 将启动委托给sc_supcreate(Value) -&gt; create(Value, ?DEFAULT_LEASE_TIME).fetch(Pid) -&gt; gen_server:call(Pid, fetch).replace(Pid, Value) -&gt; gen_server:cast(Pid, {replace, Value}).delete(Pid) -&gt; gen_server:cast(Pid, delete).%% gen_server回调init([Value, LeaseTime]) -&gt; Now = calendar:local_time(), StartTime = calendar:datetime_to_gregorian_seconds(Now), {ok, #state{value = Value, % 初始化进程状态 lease_time = LeaseTime, start_time = StartTime}, time_left(StartTime, LeaseTime)}. % 初始化超时设置time_left(_StartTime, infinity) -&gt; infinity;time_left(StartTime, LeaseTime) -&gt; Now = calendar:local_time(), CurrentTime = calendar:datetime_to_gregorian_seconds(Now), TimeElapsed = CurrentTime - StartTime, case LeaseTime - TimeElapsed of Time when Time =&lt; 0 -&gt; 0; Time -&gt; Time*1000 end.handle_call(fetch, _From, State) -&gt; #state{value = Value, lease_time = LeaseTime, start_time = StartTime} = State, TimeLeft = time_left(StartTime, LeaseTime), {reply, {ok, Value}, State, TimeLeft}. % 取出进程状态中的值handle_cast({replace, Value}, State) -&gt; #state{lease_time = LeaseTime, start_time = StartTime} = State, TimeLeft = time_left(StartTime, LeaseTime), {noreply, State#state{value = Value}, TimeLeft};handle_cast(delete, State) -&gt; {stop, normal, State}. % 发出关闭信号handle_info(timeout, State) -&gt; {stop, normal, State}.terminate(_Reason, _State) -&gt; sc_store:delete(self()), % 删除进程的键 ok.code_change(_OldVsn, State, _Extra) -&gt; {ok, State}. 实现sc_store模块（src/sc_store.erl） 12345678910111213141516171819202122232425262728293031323334353637%%%-------------------------------------------------------------------%%% @author Administrator%%% @copyright (C) 2019, &lt;COMPANY&gt;%%% @doc%%%%%% @end%%% Created : 04. 十二月 2019 20:34%%%--------------------------------------------------------------------module(sc_store).-author(&quot;Administrator&quot;).%% API-export([ init/0, insert/2, delete/1, lookup/1]).-define(TABLE_ID, ?MODULE).init() -&gt; ets:new(?TABLE_ID, [public, named_table]), ok.insert(Key, Pid) -&gt; ets:insert(?TABLE_ID, {Key, Pid}).lookup(Key) -&gt; case ets:lookup(?TABLE_ID, Key) of [{Key, Pid}] -&gt; {ok, Pid}; [] -&gt; {error, not_found} end.% 利用模式匹配删除表项delete(Pid) -&gt; ets:match_delete(?TABLE_ID, {'_', Pid}). 打造应用层API模块(src/simple_cache.erl) 123456789101112131415161718192021222324252627282930313233343536373839404142434445%%%-------------------------------------------------------------------%%% @author Administrator%%% @copyright (C) 2019, &lt;COMPANY&gt;%%% @doc%%%%%% @end%%% Created : 04. 十二月 2019 20:44%%%--------------------------------------------------------------------module(simple_cache).-author(&quot;Administrator&quot;).% 打造应用层API模块%% API-export([ insert/2, lookup/1, delete/1]).insert(Key, Value) -&gt; case sc_store:lookup(Key) of {ok, Pid} -&gt; sc_element:replace(Pid, Value); {error, _} -&gt; {ok, Pid} = sc_element:create(Value), sc_store:insert(Key, Pid), sc_event:create(Key, Value) end.lookup(Key) -&gt; try {ok, Pid} = sc_store:lookup(Key), {ok, Value} = sc_element:fetch(Pid), {ok, Value} catch _Class:_Exception -&gt; {error, not_found} end.delete(Key) -&gt; case sc_store:lookup(Key) of {ok, Pid} -&gt; sc_element:delete(Pid); {error, _Reason} -&gt; ok end. 进阶需要学习的内容rebar​ rebar是一个附带许多标准功能的便携Erlang脚本 erlang.mk​ erlang.mk则是一个很小但却可以是非常快编译文件的神奇makefile 文件 OPT applications 和 OTP release​ OTP applications和OTP release项目结构是不同的，一个OTP application 可以看成一个拥有最高级监控树(如果有的话)，并且下面可能有一大堆的依赖项(a bunch of dependencies).一个OTP release通常是多个OTP applications的组合，这些application之间可能会有依赖关系，也可能没有。这就导致了两种主要的部署applicaitons的方式","link":"/2024/03/14/erlangOtp/"},{"title":"erlang基础","text":"1、模块的命名-moudle(Name) Name为模块名称也是这个文件的名称,模块名必须与文件名一致 2、数据类型 元组（tuple）一个元组可以容纳不同类型的值，一对花括号括起来，以若干个逗号分割的值 就形成了一个元组，如{test,18}，_（下划线）作为占位符，表示那些我们不关心的变量，符号（_）称为匿名变量 列表（list）将若干个以逗号分割的值用一对中括号括起来，就形成了一个列表，比如[{name,test},{age,19}] 浮点数(float)5/3 1.66667(正常取值)（注意： “/”永远返回浮点型 比如 4/2 结果为2.0）5 div 3 1（取整除数）5 rem 3 2（取余数） 原子（atom 表示不同的非数字常量值）是一串以小写字母开头，后跟数字、字母或下划线（_）或邮件符号（@）的字符使用单引号引起来的字符也是原子，使用这种形式，原子就可以用大写字母作为开头或者包含非数字字符，如 'Monday'、'+'、'*' 字符串(str)严格地讲，Erlang并没有字符串，字符串实际上就是一个整数列表，用双引号（“）将一串字符串括起来就是一个字符串。可以使用$符号来表示字符的整数值，例如，$a实际上就是一个整数，表示字符a 注：命令f()会让shell释放它所绑定过的所有变量，执行这个命令后，所有的变量都变成自由变量 记录（record）声明一个记录：-record(Name,{key1 = Default1,key2 = Default2,key3})使用一个记录#Name{key1 = 1,Key3 = 0}注意：记录是元组的另一种形式 映射组（map）：关联式键-值存储创建一个映射M = #{a =&gt; 1, b =&gt; 2}更新一个映射M2 = M#{a ：= 3, b :=4}表达式 K =&gt; V有两种用途，一种是将现有的键K的值更新为新值V,另一种是给映射组添加一个全新的K-V对，这个操作总是成功的 表达式K := V的作用是将现有键K的值更新为V。如果被更新的映射组不包含键K,这个操作就会失败 3、比较运算符 运算符 描述 == 等于 /= 不等于 =:= 精确等于 =/= 精确不等于 =&lt; 小于或等于 &lt; 小于 &gt;= 大于或等于 &gt; 大于 注： 等级排序： number &lt; atom(基元) &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary 从上可知： 任何的数字都比任何的基元小，而任何的元组也都小于任何的列表 4、模式匹配Erlang的模式匹配可以用于： 变量赋值 控制程序的执行流程 从复合数据类型中提取值 5、函数和模块 函数 函数的名称是一个基元，一个函数的头包括名字，随后是一对括号，在里面包含多个形式的参数或者没有参数。在Erlang中，函数参数的数量叫做元数。使用箭头 -&gt; 来分割函数头和函数体。 模块 模块文件通常存放在以 .erl 为扩展名的文件中，要运行一个模块，首先需要编译它，编译成功后的模块文件其扩展名为.beam 模块指令 每个模块都拥有一个 -attribute(Value)格式的属性列表。它们通常放在模块的开始 , 如 123456789101112% Name 为模块名称-module(Name) % Function为函数的名称，Arity为元数即参数的个数-export([Function/Arity]) % 这个指令会在编译阶段导出模块中的所有函数，% 另一种方法是在编译这个文件的时候加上特定的选项 c(Mod，[export_all]).-compile(export_all) % 允许你从其他的模块中导入函数然后在本地调用-import(Module,[Function/Arity]) 6、Erlang顺序编程 case结构 case 表达式有如下的形式 123456case conditional-expression of Pattern1 -&gt; expression1,expression2,...; Pattern2 -&gt; expression1,expression2,...; ... Pattern -&gt; expression1,expression2,...end 使用的关键字是case、of和end ,对conditional-expression求值，然后和Pattern1,...,Pattern进行匹配（模式匹配），直到一个模式匹配成功 下面给个例子： 123456case lists:member(foo,List) of true -&gt; ok; false -&gt; {error,unknown_element} end%% lists:member函数检查基元foo是否是列表List的一个成员元素，如果是返回ok,不是则返回{error,unknown_element} if结构 if结构就像一个没有conditional-express和of关键字的case语句 123456if Guard1 -&gt; expression1,expression2,..; Guard2 -&gt; expression3,expression4,..; ...; GuardN -&gt; expressionN,expressN2,..end 保护元表达式Guard1,...,GuardN按次序进行计算，直到其中的一个计算结果为true. 如果为true则执行对应下的语句。 保护元 保护元是一个额外的限制条件，它应用于函数的case或者receive语句中，保护元应该放在-&gt;之前来分隔语句的主体和头部 保护元由when关键字和紧跟其后的一个保护元表达式组成，只有在模式匹配和保护元表达式求值结果为基元true的情况下，语句才会执行 下面给个例子： 123%% 阶乘factorial(N) when N &gt;0 -&gt; N * factorial(N-1);factorial(0) -&gt;1. 内置函数 Erlang中有很多内置函数来处理内置类型，例如列表和元组 123List = [one,two,three,four,five].Tuple = {1,2,3,4,5}. 函数名称 函数描述 hd/1 返回列表的第一个元素 ，例如：hd(List) tl/1 返回删除第一个元素后的其余部分 length/1 返回一个列表的长度 tuple_size/1 返回元组元素的数目 ,例如：tuple_size(Tuple) element/2 返回元组的第n个元素,例子：element(2,Tuple) 返回2 setelement/3 替换元组中的第一个元素，并返回新的元组，例子：setelement(3,Tuple,three) 返回{1，2，three，4，5} erlang:append_element/2 向元组添加一个元素作为最后的元素,并返回新的元组，例子：erlang:append_element(Tuple,6) 返回{1，2，3，4，5，6} 类型转换 类型转换必须是内置函数 函数名称 函数描述 atom_to_list/1, list_to_atom/1, list_to_existing_atom/1 它们实现基元和字符串的相互转换，如果基元在运行时系统中的当前会话里没有使用过，那么调用函数list_to_existing_atom/1将会失败 list_to_tuple/1, tuple_to_list/1 这两个函数实现元组类型和列表类型的相互转换 float/1, list_to_float/1 这两个函数都产生一个float类型，一个是把一个整数参数转换成一个浮点数，另外一个是把一个字符串转换成一个浮点数 float_to_list/1, integer_to_list/1 这两个函数都返回字符串 round/1, trunc/1, list_to_integer/1 它们都返回整数 ，例子： round(10.5).返回11，trunc(10.5).返回10 采用debugger:start()命令启动调试器 要想追踪一个模块，需要使用debug_info标志来编译它 在Erlang终端中，使用以下两个命令中的一个 123c(Module,[debug_info]).compile:file(exception,[debug_info]). guard(断言) 当元组的元素数量变得非常庞大时，我们会很难记住元组中每个元素的确切含义，记录（record）就提供了一种方法把一个名称与元组中的一个元素对应起来，从而解决了这个烦恼 注意：record不是一个shell命令,记录的声明只能用于Erlang源代码而不能用于shell 1234567891011121314record语法：-record(Name,{ key1 = Default1, key2 = Default2, ...}).Name是记录的名字，key1,key2...是记录中的字段名，这些名字必须是原子在shell中读取记录的定义，可以用rr(read record的缩写)这个命令例如：rr(&quot;records.hrl&quot;)在shell中，rd的使用方法，直接在里面定义一个记录，并读取rd（person,{name = &quot;abc&quot;, age = 12}） 12-import (lists,[map/2,sum/1])意味着函数map/2是从lists模块中导入的，然后在程序中可以直接使用map(Fun,...)而不必去写list:map(Fun,...)-export([total/1])意味着函数total/1能够在模块本模块之外调用，只有从一个模块中导出的函数才能在模块之外调用 异常 抛出异常 通过调用下面几个内建的异常产生函数来显示地产生一个错误 exit(Why) 当想要终止当前进程时，就需要用到这个函数。如果是这个异常未被捕获，那么系统会向所有与当前进程相连接的进程广播{'EXIT',Pid,Why}消息 throw(Why) 这个函数用于抛出一个调用者可能会捕获的异常 erlang:error(Why) 这个函数用于抛出那些“崩溃错误”，这些异常应该是那些调用者不会真正意识到要去处理的致命错误，可以将它等同于内部产生的系统错误 捕获异常（try...catch） Erlang捕获异常的语法结构 1234567891011try FuncOrExpressionSequence of Pattern1 [when Guard1] -&gt; Expression1; Pattern2 [when Guard2] -&gt; Expression2; ...catch ExceptionType: ExPattern1 [when ExGuard1] -&gt; ExExpression1; ExceptionType: ExPattern2 [when ExGuard2] -&gt; ExExpression2; ...after AfterExpressionsend try...catch就像一个case表达式的增强版本。基本上它就是一个在尾部带有catch和after块的case表达式 try..catch的执行流程：先对FuncOrExpressionSequence求值，如果不产生异常，那么函数的返回值就对Pattern1(连同可选的断言Guard1)、Pattern2等进行模式匹配 如果在FuncOrExpressionSequence中有异常抛出，那么就会逐个匹配catch下的ExPattern1等模式， ExceptionType是原子throw、exit或error中的一个，告诉我们异常是以什么方式产生的。若未标明ExceptionType,那么默认的值就是throw。","link":"/2024/03/11/erlang%E5%9F%BA%E7%A1%80/"},{"title":"erlang套接字编程","text":"gen_tcp:controlling_process(Socket, NewPid) 函数来把一个套接字的控制进程改为新的控制进程NewPid Erlang的套接字可以以3种模式打开：active、active once 或 passive。 在调用gen_tcp:connect(Address, Port, Options) 或者 gen_tcp:listen(Port, Options) 时通过选项{active, true | false | once} 设置套接字的参数来实现 {active, true} 那么程序会创建一个主动套接字 {active, false} 则会创建一个被动套接字 {acitve, once} 也会创建一个主动套接字，但这个套接字仅接收一条消息，当它接收完这条消息后，如果想让它接收下一条消息，那么就必须再次激活它 主动套接字和被动套接字的区别在于套接字接收到消息之后的工作机制： 建立主动套接字之后，当数据到达时系统会向控制进程发送{tcp, Socket, Data} 消息。 而控制进程无法控制这些消息流。一个独立的客户机有可能会向系统发送成千上万条消息，而这些消息都会被转送到控制进程。但控制进程却无法停掉这个消息流。 如果套接字以被动模式打开，那么控制进程必须调用gen_tcp:recv(Socket, N) 来接收来自于套接字的数据。它会尝试从套接字接收N字节的数据。如果N为0，那么所有可用的字节数据都会返回。在这种情况下，服务器可以通过选择调用gen_tcp:recv的时机来控制来自客户机的消息流 3种方式编写一个服务器的消息接收循环主动型消息接收（非阻塞） 被动型消息接收（阻塞） 混合型消息接收（半阻塞） 1、主动型消息接收（非阻塞）1234567891011{ok, Listen} = gen_tcp:listen(Port, [..., {active, true}, ...]),{ok, Socket} = gen_tcp:accept(Listen),loop(Socket).loop(Sokcet) -&gt; receive {tcp, Socket, Data} -&gt; ... do something with the data ... {tcp_closed, Socket} -&gt; ... end. 这个进程无法控制服务器循环中的消息流。如果客户端发送的数据快过服务器可以处理的速度，那么系统就会被消息淹没 ，消息缓冲区会被塞满，系统可能就会莫名奇妙的崩溃。 这种类型的服务器被称为异步服务器，因为它不会阻塞客户端。只有在我们可以确信服务端的性能能够跟上客户机的需求时，才应该选择使用异步服务器 2、被动型消息接收（阻塞）服务器通过设置{active, false} 选项来以被动模式打开一个套接字，它不会因为一个过于活跃的客户机通过发送大量数据的攻击而崩溃。 每次程序想要接收数据的地方都会调用gen_tcp:recv。调用recv函数时客户端会被阻塞 123456789101112{ok, Listen} = gen_tcp:listen(Port, [..., {active, false}, ...]),{ok, Socket} = gen_tcp:accept(Listen),loop(Socket).loop(Sokcet) -&gt; case gen_tcp:recv(Socket, N) of {ok, Bin} -&gt; ... do something with the data ... loop(Socket); {tcp_closed, Socket} -&gt; ... end. 3、混合型消息接收（半阻塞）在这个模式中，套接字是主动的但是仅仅针对一个消息。在控制进程发过一个消息后，必须显示地调用函数inet:setopts来把它重新激活以便接收下一个消息。在此之前，系统会处于阻塞状态。 12345678910111213{ok, Listen} = gen_tcp:listen(Port, [..., {active, once}, ...]),{ok, Socket} = gen_tcp:accept(Listen),loop(Socket).loop(Sokcet) -&gt; receive {tcp, Socket, Data} -&gt; ... do something with the data ... inet:setopts(sock, [{active, once}]), loop(Socket); {tcp_closed, Socket} -&gt; ... end.","link":"/2024/03/12/erlang%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"},{"title":"erlang并发","text":"1、进程的生命周期（从创建到销毁的过程）Pid = spawn(Fun) 创建一个新的并发进程（Pid (process identifier 进程标识符)） 进程间通过发送信息进行通信，所以必须双方必须知道对方的Pid才可以发起通信 如何注册一个进程？ Erlang中有4个BIF用于管理注册进程 操作 说明 register(AnAtom,Pid) 将一个进程Pid注册一个名为AnAtom的原子，如果原子AnAtom已经被另外一个注册进程所使用，那么注册就会失败。 unregister(Antom) 移除与AnAtom相对应进程的所有注册信息（如果一个注册进程死亡，那么它也会被自动取消注册） whereis(AnAtom) -&gt; Pid | undefined 判断AnAtom是否已经被其他进程注册，如果成功，返回进程标识符Pid,没有成功则返回原子undefined registered() -&gt; [AnAtom :: atom()] 返回一个系统中所有已经注册的名称列表 两个进程之间如何相关联? 两个进程A和B，它们之间建立链接，是其中一个进程调用了BIF(Built In Function 内置函数) link(Pid)。 一旦两个进程之间建立链接，它们就会相互监视，若A消亡，系统就会向B发送一个叫做退出的信号，反之也一样。 操作 说明 link(Pid) -&gt; true 将当前进程与Pid进程之间链接起来 unlink(Pid) -&gt; true 取消链接 exit(why) -&gt; none() 终止当前进程 exit(Pid,why) -&gt; true 向Pid所指示的进程发出一个退出信号，并把退出原因设置为why erlang:monitor(process,Item) -&gt; MonitorRef 建立一个监视器，Item为一个PId或者一个进程的注册名 process_flag(trap_exit,true)可以把创建的进程变为一个系统进程（system process）,把一个普通进程转换为一个可以捕获退出信号的系统进程 -spec 表示这是对一个函数进行规范，人话就是：说明函数的参数或者返回值的类型@spec spawn_link(Fun) -&gt; Pid这个原语非常像spawn(Fun),但它除了创建进程之外还会在这个两个进程之间建立链接。spawn_link是一个原子操作，它和spawn+link操作并不等价，因为在执行spawn和link的间隙之间，所创建的进程有可能就已经消亡了 @spec process_flag(trap_exit,true)这个原语把当前进程转换为系统进程，系统进程可以接收和处理退出信号 process_flag(trap_exit, 捕获状态) 捕获状态 退出信号 动作 true kill 消亡，向链接集广播退出信号killed true x 将{‘EXIT’, PID, X} 加入到邮箱 false normal 基础运行，不做任何事，屏蔽退出信号 false kill 消亡，向链接集广播退出信号killed false x 消亡，向链接集广播退出信号x 捕获退出的编程模式 模式1： 不在乎创建的进程是否崩溃1Pid = spawn(fun() -&gt; ... end) 如果没有其他语句。那么如果这个被生成的进程崩溃，当前进程会毫无察觉地继续执行自己的其他任务 模式2： 如果创建的进程崩溃那么我也自行消亡1Pid = spawn_link(fun() -&gt; ... end) 如果新生成的进程异常崩溃而发出非正常的退出信号，当前进程也会随之消亡 模式3： 如果我创建的进程崩溃我需要处理错误123456789101112process_flag(trap_exit, true),Pid = spawn_link(fun() -&gt; ... end),...loop(...).loop(State) -&gt; receive {'EXIT', SomePid, Reason} -&gt; %% do something with the error loop(NewState); ... end 如果把经过设置的执行loop函数的进程链接到另外一个进程，那么loop进程虽然会捕获到退出信号但是不会自行消亡。另一个进程即将消亡时，loop进程会捕获到所有来自濒死进程的退出信号并且将其翻译为消息，然后执行任何它所期望的后续处理。 2、并发编程3个原语：spawn、send(使用！操作符)和receive 创建进程 通过使用内置函数spawn(Module, Function, Arguments)可以生成一个新的进程，并对Module模块中导出函数Function以列表Arguments作为参数进行求值，内置函数spawn/3会返回一个进程标识符（process identifier）pid 可以使用终端命令i()来查看当前运行时系统正在执行的进程 终端崩溃会自动产生一个新终端进程 接收一个发给当前进程的消息，它的语法如下 1234567891011121314151617% receive... endreceive Pattern1 [when Guard1] -&gt; Expression1; Pattern2 [when Guard2] -&gt; Expression2; ...end% 带超时的`receivereceive Pattern1 [when Guard1] -&gt; Expression1; Pattern2 [when Guard2] -&gt; Expression2; ...after Time -&gt; Expressionsend.%% 如果在进入receive表达式后在Time所规定的毫秒数内没有接收到能够匹配的消息，那么进程就会停止等待，并对Expression进行求值。 Erlang的每个进程都有与之对应的邮箱。当向进程发送消息时，消息就被送入邮箱之中。当系统对receive语句进行求值时，就是对进程邮箱进行检查的唯一机会。 receive的内部工作机制 注册进程 如果想要向一个进程发送消息，那么就需要知道它的Pid。Erlang有一种机制可以用于发布一个进程的标识符以便其他进程可以与之通信，这种进程就叫注册进程。 12345%% 将一个进程Pid注册一个名为AnAtom的原子，如果原子AnAtom已经被另一个注册进程所使用，那么注册就会失败register(AnAtom, Pid)%% 移除与AnAtom相对应进程的所有注册信息unregister(AnAtom) 注：如果一个注册进程死亡，那么它也会被自动取消注册 3、并发编程中的错误处理​ 链接（link）、退出信号（exit signal）、系统进程 链接进程 如果一个进程在某种程度上依赖于另一个进程，那么它就需要时刻紧盯着第二个进程的运行状态。 现有A、B两个进程，如果其中的一个进程调用了BIF link(P)(P的值是另一个进程的PID),那么这两个进程就建立了链接。一旦两个进程建立链接，它们就会自动互相监视。此时，若A消亡，系统就会向B发送一个叫做退出信号的东西，反之，若B消亡，则A也会接受到这个信号 ​ 如果一个进程接受到退出信号，若没有对这个接受进行特殊处理，那么这个退出信号的默认处理就是让该进程也一并退出。但也可以让这个进程捕获退出信号，当进程进入这个捕获状态时，那么我们称其为系统进程 4、gen_servergen_server行为模式的接口包含六个函数：init/1、handle_call/3、handle_cast/2、handle_info/2、terminate/2、code_change/3 gen_server行为模式最精简的实现模块： 123456789101112131415161718-module(...).-behaviour(gen_server).-export([init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2,code_change/3]).-record(state,{}).init([]) -&gt; {ok, #state{}}.handle_call(_Request, _From, State) -&gt; Reply = ok, {reply, Reply, State}.handle_cast(_Msg, State) -&gt; {noreply, State}handle_info(_Info, State) -&gt; {noreply, State}.terminate(_Reason, _State) -&gt; ok.code_change(_OldVsn, State, _Extra) -&gt; {ok, State}. gen_server实现API的库函数 库函数 对应的回调函数 描述 gen_server:start_link/4 Module:init/1 启动并链接一个gen_server容器进程 gen_server:call/2 Module:handle_call/3 向gen_server进程发送同步消息并等待应答 gen_server:cast/2 Module:handle_cast/2 向gen_server进程发送异步消息 N/A Module:handle_info/2 处理通过call或cast函数以外的手段发送给gen_server容器的消息，这些都是带外（out_of_band）消息 gen_server:call/2 调用方会等待应答（同步消息） gen_server:cast/2 无须坐等应答（异步消息） handle_info/2没有对应的gen_server库函数，这个回调是一个重要的特例，所有未经call或cast库函数发送至gen_server信箱的消息都由它处理（通常是直接用！运算符发送的裸消息） 带外消息处理：采用call或cast以外的手段发送消息给gen_server进程的所有消息都由handle_info/2回调函数处理。这些消息都被归类为带外消息 tr_server:start_link/1 ---对用户屏蔽调用----&gt; gen_server:start_link/4 -----------然后新进程随后会回调---------&gt;tr_server:init/1 gen_server:start 函数可以四个参数（ServerName,Module,Args, Options) 第一个参数ServerName是服务名，可以省略掉。具有相同服务名的模块在一个节点中只能启动一次，重复启动会报错，为{error, {already_started, Pid}}。具有服务名的服务进程可以使用服务名来调用，没有服务名的只能通过进程号Pid来调用。通常有名字的服务进程会使用模块名作为服务名称，即代码中定义的宏 -define(SERVER, ?MODULE),然后再需要使用服务名的地方填入?SERVER 第二个参数Module是模块名，一般而言API和回调函数是写在同一个文件里，所以就用?MODULE,表示本模块的模块名 第三个参数Args是回调函数init/1的参数，会原封不动地传给init/1 第四个参数Options是一些选项，可以设置debug、超时等东西 5、杂项Module:Func(Args) 与Func(Args)的区别 Erlang函数有local call和external call的区别，Local call 就是在函数在被定义的模块里面被调用,可以直接被调用Func(Args); External call 就是显式的使用Module:Func(Args)来调用或import别的模块进来的调用. 当同一个模块有2个版本被加载里，所有的local call都可以工作在当前版本状态，但是：external call只能调用到最新的版本！(代码热更的时候) 用link进行关联的进程组，只要其中一个进程终止，其他进程也会同时终止 通过process_flag(trap_exit, true) 将进程设置为系统进程，不会随着其他进程退出而退出，同时还能监控其他进程","link":"/2024/03/12/erlang%E5%B9%B6%E5%8F%91/"},{"title":"erlang日志","text":"日志与事件处理SASL（System Architectrue Support Libraries (系统架构支持库))，它负责错误日志、过载保护等。 它表示的是身为Erlang/OTP五大基础应用(erts、kernel、stdlib、sasl和compiler)之一的系统架构支持库。 日志级别通常分为5个，分别是：critical(或server)、error、warning、info和debug Erlang/OTP的基本发行版本便提供了日志功能支持。其主要功能由标准库中kernel应用的error_logger模块提供，供OTP行为模式使用的扩展日志功能则由SASL应用提供。 1、标准日志函数12345678error_logger:error_msg(Format) -&gt; ok.error_logger:error_msg(Format, Data) -&gt; ok.error_logger:warning_msg(Format) -&gt; ok.error_logger:warning_msg(Format, Data) -&gt; ok.error_logger:info_msg(Format) -&gt; ok.error_logger:info_msg(Format, Data) -&gt; ok. 2、用gen_event编写自定义事件处理器gen_event行为模式接口与gen_server类似：如其中的init、code_change 和 terminate 回调函数以及handle_call 和handle_info回调（在参数和返回值方面有所差异），gen_event 接口用 handle_event/2取代了handle_cast/2这个正是接收错误日志事件的地方。 gen_event 和 gen_server 之间的一个重要区别在于当启动新的gen_server容器时，需要告诉它应该使用那个回调模块；但在启动gen_event容器（也称为事件管理器）时，起初是无须任何回调模块的。相反，在容器完成初始化之后，可以动态添加或删除一个或多个处理器。当事件被投递至事件管理器时，事件管理器会调用当前已注册的所有处理器模块来处理事件。","link":"/2024/03/14/erlang%E6%97%A5%E5%BF%97/"},{"title":"git笔记","text":"1、git命令的介绍： 指令 描述 git init 将某目录变成git可以管理的仓库（在此文件夹下生成了.git文件夹） git add xxx.md 添加xxx.md文件到暂存区（从工作区–&gt;暂存区） git add . 这是添加所新建的所有文件到暂存区 git commit -m “提交注释” 一次性提交多个文件（add进来的文件），将文件提交到本地仓库（暂存区–&gt;本地仓库） git status 可以时刻知道仓库的当前状态 git diff xxx.md 查看修改的内容（与提交进去的文件相比） git log 查看仓库历史记录 ，命令显示从最近到最远的提交日志 git reflog 查看命令历史 2、版本回退：git reset –hard HEAD^ 将会重置HEAD返回到另外一个commit,这个是个比较危险的动作，具有破坏性，数据因此可能会丢失，如果想找回原来的数据就使用 git reflog命令 Git中，用HEAD表示是当前的版本，上一个版本就是HEAD^,上上个版本就是HEAD^^, 当然往上n个版本写n个^比较容易数不过来，所以写成HEAD~n,如HEAD-10 12345# 回退到上一个版本git reset --hard HEAD^ # 回退到上10个版本git reset --hard HEAD~10 也可以指定回滚的版本号，版本号用git log查看commit id前7位 如果我们忘记回退前的版本号，git reflog 命令记录了每一次的命令操作，包含了所有版本的版本号 --hard参数含义： --hard会回退到上个版本的已提交状态 --soft会回退到上个版本的未提交状态 --mixed会回退到上个版本已添加但未提交的状态 3、撤销操作 指令 描述 git checkout -- filename 把文件在工作区的修改全部撤销，回到最近一次git commit 或git add 时的状态。 git reset HEAD filename 把暂存区的修改撤销掉，重新放回到工作区中 git rm filename 删除版本库中的文件，比如执行 git rm test.txt ,然后再执行commit操作则成功删除 git rm dir -r 删除版本库中的文件夹 git checkout -- test.txt 撤销删除 4、远程仓库首先需要拥有github的账号 创建SSH Key密钥 1ssh-keygen -t rsa -C &quot;注册github的email&quot; 然后在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，然后将id_rsa.pub里面的内容添加到github上面 1234567891011121314151617181920212223242526272829# 先在github上面创建仓库,如heclam.github.io.git# 关联远程仓库# origin 为本地仓库# https://github.com/heclam/heclam.github.io.git为仓库的地址git remote add origin https://github.com/heclam/heclam.github.io.git# 一般push之前先pull一下 把远程仓库的内容更新到本地仓库# 将本地仓库推送到远程分支上git push -u origin master# orgit push#由于远程库是空的，我们第一次推送 master 分支时，加上了 `-u` 参数，Git不但会把本地的master分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以不使用 `-u`参数。#列出已存在的远程分支git remote# 删除添加的远程库git remote remove name# 从远程克隆仓库git clone https://github.com/heclam/heclam.github.io.git# 修改远程仓库地址git remote set-url origin &lt;remote-url&gt; 5、分支管理master：默认为主分支，Head 指向哪个分支，则表明那个分支为当前分支 指令 描述 git branch test 创建分支test git checkout test 切换至test分支 git checkout -b test 创建了一个test分支并且切换到了test分支中 git branch 查看当前分支 git merge name 合并指定分支与当前分支，name为分支的名称（如master分支需要合并test分支的内容，则在master分支下执行 git merge test） git merge -no-ff -m “…” 分支名 禁用git合并时默认的fast-forward模式，生成新的commit加入分支信息 git branch -d 分支名 删除分支 6、工作现场存储 指令 描述 git stash 将当前工作现场储藏起来，等以后恢复现场后继续工作 git stash list 查看储藏的工作现场 git stash apply 恢复储藏的工作现场,stash内容并不删除，你需要用git stash drop来删除 git stash pop 恢复的同事把stash内容也删除了 7、多人协作123456789# 从远程库克隆到本地仓库，克隆对应的分支，比如这里为test分支git checkout -b test origin/test # 用git push origin test（分支名） 推送自己的修改# 如果失败，因为远程分支比本地分支内容新，需要先git pull 合并一下# 如果有冲突则解决冲突后在提交# 使用git push origin test 推送到远程库# 如果 git pull 提示 “no tracking information”，则需要创建本地分支和远程分支的关联git branch --set-upstream test origin/test 8、标签管理1234567891011121314151617181920212223242526# 打标签git tag tagName # 例子：git tag v0.1 忘记在某次commit时打标签，可以使用以下的方式# 将commit id为2893423的提交打上v1.0标签git tag v1.0 2893423 # 查看标签git tag # 查看标签信息git show &lt;tagname&gt;# 创建带有说明的标签，-a 指定标签名，-m指定说明git tag -a v2.0 -m &quot;记录信息&quot; 23498222（commit id）# 删除指定标签git tag -d tagName# 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。# 如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt;#一次性推送全部尚未推送到远程的本地标签git push origin --tags# 删除已推送到远程库的标签，先从本地删除，再从远程删除git tag -d tagname &amp; git push origin :refs/tags/tagname 9、忽略特殊文件Git仓库也可以有多个.gitignore文件，.gitignore文件放在哪个目录下，就对哪个目录（包括子目录）起作用","link":"/2019/06/15/git%E7%AC%94%E8%AE%B0/"},{"title":"hexo+github搭建我的博客","text":"1、本地环境搭建搭建需要的环境 node github hexo 首先在自己的磁盘目录下新建一个文件夹，如heclam.github.io，然后cd进入该目录下 123456789101112131415161718192021# 切换目录到 D:\\heclam.github.io, 在git bash下# 设置npm的源为阿里的源npm config set registry https://registry.npmmirror.com# 安装hexonpm install hexo-cli -g# 初始化博客hexo init# 安装依赖npm install# 生成静态文件hexo g# 启动hexo服务hexo s# 然后在浏览器上输入 http://localhost:4000/即可看到运行成功 2、部署到github上2.1 在github上面新建一个仓库, 名为用户名.github.io2.2 本地设置git账号123# 在git bash下git config --global user.name &quot;github用户名&quot;git config --global user.email &quot;github注册邮箱&quot; 2.3 本地创建SSH秘钥 ssh-keygen -t rsa -C “github注册邮箱” 然后在本地找到公钥的位置，一般在c:\\Users\\用户名\\.ssh 目录下，打开id_rsa.pub文件，拷贝里面的内容。 在github上面新建ssh key github主页 -&gt; 头像 -&gt; settings -&gt; SSH and GPG keys -&gt; SSH Keys -&gt; New SSH key 点击New SSH key, Title随便注释即可，将上面的公钥复制粘贴到key下然后点击Add SSH key按钮即可 测试是否可连接 ssh git@github.com 出现连接成功则成功 2.4 将博客部署到GitHub上安装hexo-deployer-git插件 npm install hexo-deployer-git –save 修改一下_config.yml文件,如 12345deploy: type: 'git' repo: git@github.com:heclam/heclam.github.io.git # 这个不一定是master，旧的可能为master,现在新建的分支默认可能都为main了，可是具体情况而定 branch: master 执行部署 12345hexo g -d# 或者拆分以上指令hexo ghexo d 如果成功则可以通过 https://&lt;github用户名&gt;.github.io/ 访问了 如https://heclam.github.io/ 3、多台电脑共同操作博客上面的设置有点鸡肋，如果换了设备则无法再对博客进行一个修改更新操作，因为保存在github上面的内容仅仅只是hexo生成的静态资源文件，而并没有源码文件，那么接下来将处理这个问题，使得我们在家里以及公司或则其他的设备都可以对这个博客进行一个修改更新操作 3.1 新建hexo分支，存放源码​ 首先我们在同一个仓库下新建一个hexo分支存放源码，这样我们在其他设备也可以获取源码,这样子不管在哪个设备上我们只需要更新hexo分支的源码即可共同管理博客里面的内容。 新建一个hexo分支，并设置为默认分支。这个逻辑就很清楚了hexo分支保存博客的源码文件，当我们执行hexo d的时候，hexo都会帮我们把生成好的静态页面文件推送到master分支上 3.2 本地创建仓库跟远程新建的hexo分支产生关联将博客源码推送到hexo分支上 12345678910111213# clone hexo分支内容# clone的是hexo默认分支内容git clone https://github.com/heclam/heclam.github.io.git# 可以将.git文件夹以外的所有内容删除# 把原来的hexo源码除了.deploy_git以外的都复制到本目录中，通过.gitignore文件可以忽略不需要版本控制的文件# 如果themes主题文件夹里面有.git文件，也需要将其删除，因为git不能嵌套上传，否则上传的时候会出错导致主题文件无法上传，这样配置的主题在其他电脑也无法使用# 将源码推送到hexo分支git add .git commit -m '添加博客源码'git push 这里完成之后，之前的源码文件已经没有任何用处了，可以选择直接删除 3.3 在新设备的操作12345678910111213141516171819# 首先需要生成ssh key添加到github,具体流程可以参考上面的2.3# clone hexo分支代码git clone https://github.com/heclam/heclam.github.io.git# 进入clone下来的目录,执行相应的指令# 这里不再需要执行hexo init了npm install hexo# 读取packages.json里面的信息，自动安装依赖npm installnpm install hexo-deployer-git --save# 最后执行# 生成静态文件hexo g# 本地服务启动hexo s# 部署到master分支hexo d 在设备准备提交内容的时候，为了保证分支同步，最好先git pull一下 hexo文档 icarus主题设置","link":"/2019/06/14/hexo-github%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"title":"java反射机制","text":"Java反射机制是指在 运行状态中 ，对于任意一个 类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。 获取class的三种方法12345678910111213141516171819202122package com.luo.test;public class TestDemo{ public static void main(String[] args){ //第一种 Class class1 = TestDemo.class; System.out.pritnln(class1.getName（）); //第二种 TestDemo demo = new TestDemo(); Class class2 = demo.getClass(); System.out.pritnln(class2.getName（）); //第三种 Class class3 = Class.forName(&quot;com.luo.test.TestDemo&quot;);//这里面的参数为类的全量限定名 System.out.pritnln(class2.getName（）); }}执行结果为： com.luo.test.TestDemo com.luo.test.TestDemo com.luo.test.TestDemo 获取这个Class有什么作用？ 获取成员方法Method 获取成员变量Field 获取构造函数Constructor 获取成员方法单独获取某一个方法是通过Class类的以下方法获得的： 123//参数：第一个参数为方法名，后面的参数为 参数类型 比如 String.class int.class(可以看下方的例子)public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的 例如有个一类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person { private String name; private int age; private String msg=&quot;hello wrold&quot;; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person() { } private Person(String name) { this.name = name; System.out.println(name); } public void fun() { System.out.println(&quot;fun&quot;); } public void fun(String name,int age) { System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;); }}public class TestDemo{ public static void main(String[] args){ try { Class c = Class.forName(&quot;com.luo.Person&quot;); Object o = c.newInstance(); Method method = c.getMethod(&quot;fun&quot;, String.class, int.class); method.invoke(o, &quot;abc&quot;, 18); } catch (Exception e) { e.printStackTrace(); } }} 12执行结果： 我叫abc,今年18岁 获取所有的成员方法： 123456789Class c = Class.forName(&quot;com.luo.Person&quot;);//不带参数则获取全部的方法Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的或者：Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的遍历数组：for (Method method : methods) 获取成员变量单独获取某个成员变量，通过Class类的以下方法实现： 1234public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量注意：field.setAccessible(true);//如果变量的访问属性为private,需设置是否允许访问 获取全部的成员变量： 1234Field[] fields = c.getDeclaredFields();然后遍历变量数组,获得某个成员变量：for(Field field : fields) 获取构造方法获取单个构造函数（传入参数） 12345public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所有的构造器，不包括其父类的构造器public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类注意： constructor.setAccessible(true);//如果构造方法为private，需设置是否允许访问 获取该类的所有构造函数 1234Constructor[] constructors = c.getDeclaredConstructors();然后遍历：for (Constructor constructor : constructors)","link":"/2019/06/26/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"java线程","text":"进程与线程的区别 进程: 进程简单的来说就是在内存中运行的应用程序，一个进程可以启动多个线程。​ 比如在windows中一个运行( xxx.EXE文件 )就是一个进程。进程是系统运行程序的基本单位 线程: 线程是是一个比进程更小的执行单位，一个线程执行过程中可以产生多个线程。 ​ 同一个线程中的进程共用相同的地址空间，同时共享进程所拥有的内存和其他资源。 并行与并发 并行：同一时间段，多个任务都在执行（单位时间内不一定同时执行） 并发：单位时间内，多个任务同时执行 使用多线程可能带来的问题：内存泄露、上下文切换、死锁 何为死锁例子：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们有必需获取相互的资源才能完成线程，比如线程A需要获取资源1（线程B也需要获取资源2）才能完成线程操作，所才会释放，现在各自抱着其他线程所需要的资源而形成死锁。 创建多线程有两种方法 继承Thread,重写run方法 1234567891011121314public class MyThread extends Thread { @Override public void run() { for (int x = 0; x &lt; 200; x++) { System.out.println(x); } }}----调用public static void main（String [] args）{ MyThread my1 = new MyThread(); my1.start();} 实现Runnable接口，重写run方法（这个比较常用，避免java单继承的限制） 123456789101112131415161718public class MyRunnable implements Runnable { @Override public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(x); } }}----调用 public static void main(String[] args) { MyRunnable my = new MyRunnable(); Thread t1 = new Thread(my); t1.start(); } 线程有3个基本状态：执行、就绪、阻塞 sleep()和wait()的区别两者的区别在于：sleep方法没有释放锁，而wait方法释放了锁 两者都可以暂停线程的执行 wait()通常用于线程间交互/通信，sleep()通常用于用户暂停执行 wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep方法执行完成后，线程会自动苏醒。 synchronized关键字synchronized关键字解决多个线程之间访问资源的同步性，它可以保证由它休息的方法或代码块再任意时刻只有一个线程执行。 用法： 修饰实力方法：给当前对象加锁，进入同步代码块前要获取当前对象实例的锁 1public synchronized void add(){} 修饰静态方法：给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。 1public synchronized static void add(){} 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁 1synchronized(object){ } 线程中常用的方法方法详解 public static void sleep(long mills) 当调用sleep()方法时，必须捕获异常或者向上层抛出异常。当线程休眠时间满时，并不一定会马上执行，因为此时有可能CPU正在执行其他的任务，所以调用了sleep()方法相当于线程进入了阻塞状态。 public static void yield() 调用yield()方法是为了让当前线程交出CPU权限，让CPU去执行其他线程。它和sleep()方法类似同样是不会释放锁。但是yield()不能控制具体的交出CUP的时间。并且它只能让相同优先级的线程获得CPU执行时间的机会。 调用yield()方法不会让线程进入阻塞状态，而是进入就绪状态，它只需要等待重新获取CPU的时间，这一点和sleep()方法是不一样的。 public final void join() join()方法的作用是等待线程对象销毁，如果子线程执行了这个方法，那么主线程就要等待子线程执行完毕之后才会销毁 setDaemon(boolean on),getDaemon() 用来设置是否为守护线程和判断是否为守护线程 守护线程依赖于创建他的线程，而用户线程则不需要。如果在main()方法中创建了一个守护线程，那么当main方法执行完毕之后守护线程也会关闭。而用户线程则不会，在JVM中垃圾收集器的线程就是守护线程。 有返回值得多线程​ 简单的实现有返回值得线程 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class CallableFuture { public static void main(String[] args) { //创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(3) ; //创建三个有返回值的任务 CallableTest2 c1 = new CallableTest2(&quot;线程1&quot;) ; CallableTest2 c2 = new CallableTest2(&quot;线程2&quot;) ; CallableTest2 c3 = new CallableTest2(&quot;线程3&quot;) ; Future f1 = pool.submit(c1) ; Future f2 = pool.submit(c2) ; Future f3 = pool.submit(c3) ; try { System.out.println(f1.get().toString()); System.out.println(f2.get().toString()); System.out.println(f3.get().toString()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); }finally{ pool.shutdown(); } }} 123456789101112131415 import java.util.concurrent.Callable; public class CallableTest2 implements Callable { private String name ; public CallableTest2(String name) { this.name = name; } @Overridepublic Object call() throws Exception { return name+&quot;返回了东西&quot;;} }","link":"/2019/07/07/java%E7%BA%BF%E7%A8%8B/"},{"title":"java集合总结","text":"List:(有序（存储顺序和取出顺序一致），可重复) ArrayList底层数据结构是数组。线程不安全J(如果想要ArrayList是实现同步，可以使用Collections的方法：List list = Collections.synchronizedList(new ArrayList()),就可以实现同步了) LinkedList底层数据结构是链表。线程不安全(LinkedList底层是双向链表) Vector底层数据结构是数组。线程安全 ​ #### 注：查询多用Arraylist（底层实现为数组），增删多则用LinkedList(底层实现为双向链表（双向链表方便往前遍历）) Set（元素不可重复） HashSet集合 底层数据结构是哈希表（是一个元素为链表的数组）+红黑树 TreeSet集合 底层数据结构是红黑树（是一个自平衡的二叉树） 保证元素的排序方式 LinkedHashSet集合 底层数据结构是由哈希表（是一个元素为链表的数组）+双向链表组成 HashSet 实现Set接口 不保证迭代顺序 允许元素为空 底层实际上是一个HashMap实例 非同步 初始容量非常影响迭代性能 TreeSet 实现NavigableSet接口 可以实现排序功能 有序，不允许为null 底层实际是一个TreeMap实例 非同步 LinkedHashSet 迭代是有序的 允许为空 底层实际是一个HashMap+双向链表实例（其实就是LinkedHashMap） 非同步 性能比HashSet差一点，因为要维护一个双向链表 初始容量与迭代无关，LinkedHashSet迭代的是双向链表 散列表（数组+链表） 不在意元素的顺序，能够快速的查找元素的数据 红黑树 红黑树是二叉搜索树。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) **从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点(每一条树链上的黑色节点数量（称之为“黑高”）必须相等)**。 Map Set&lt;Map.Entry&lt;k key,v value&gt; entrySet();返回的是键值对对象的集合 Set keySet(); 获取集合中所有的键的集合 Collection values(); 获取集合中所有值得集合 Map集合的特点：将键映射到值得对象，一个映射不能包含重复的键，每个键最多只能映射到一个值 Map和Collection集合的区别： ​ 1.Map集合存储元素师成对出现的，Map的键是唯一的，值是可以重复的 ​ 2.Collection集合存储元素是单独出现的，collection的儿子set是唯一的，List是可重复的 HashMap1234特点： * 无序，允许为null,非同步 * 底层由散列表（哈希表）实现 * 初始容量和装载因子对HashMap影响挺大的，设置小了不好，设置大了也不好 HashMap与Hashtable比较 从存储结构和实现来讲基本上都是相同的。Hashtable和HashMap的最大的不同是它是线程安全的，另外它不允许key和value为null。Hashtable是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换 LinkedHashMap（继承HashMap） 底层是散列表和双向链表 允许为null,不同步 插入的顺序是有序的（底层链表致使有序） 装载因子和初始容量对LinkedHashMap影响很大 TreeMap TreeMap实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，致使我们的TreeMap是有序的！ TreeMap底层是红黑树，它方法的时间复杂度不会太高 非同步，想要同步可以使用Collections来进行封装 使用Comparator或者Comparable来比较key是否相等与排序的问题 key不能为null，为null抛出NullPointException的异常 ConCurrentHashMap 底层实现是：散列表和红黑树，与hashMap是一样的 ConcurrentHashMap支持高并发的访问和更新，他的线程是安全的 检索操作不用加锁，get方法是非阻塞的 key和value都不允许为空","link":"/2019/06/29/java%E9%9B%86%E5%90%88/"},{"title":"linux杂项","text":"1、linux绑定ip地址：https://blog.csdn.net/nyist_zxp/article/details/131338441 查看可绑定的网段ip 2、screen 使用（idserver的启动） 12345678910111213141516171819202122232425# 显示目前所有的screen终端screen -ls或screen -list#新建终端screen -S screenName(终端名称)#执行完指定命令后#使用快捷键Ctrl+A+D,关闭窗口即可实现程序的后台运行# 重现窗口(回到终端)screen -r screenName(终端名称)#例子：（idServer后台运行）cd /data/idServerscreen -S idServer // 新建终端./idserver &amp; // 执行启动命令使用快捷键Ctrl+A+D,进行退出screen -list 可查看","link":"/2024/03/18/linux%E6%9D%82%E9%A1%B9/"},{"title":"markdown语法","text":"嗯，下面记录一下markdown的语法 1.斜体和粗体12341.*斜体* ， _斜体_2.**粗体**3.***加粗斜体***4.~~删除线~~ 2.标题1# 一级标题（前面“#”有多少个就表示为几级标题） 3.超链接 行内式 []里面写链接文字，（）里面写链接地址，（）中的“ ”可以为链接指定title属性，title属性可加可不加 12[链接文字]（链接地址 &quot;title 可加可不加&quot;）比如： [百度官网链接](http://www.baidu.com &quot;百度&quot;) 参考式 参考式链接分为两部分， [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以作为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址 1234567[Google][1][我的github][2][爱奇艺][][1]:http://www.google.com &quot;Google&quot;[2]: http://myName.github.io &quot;github&quot;[爱奇艺]：http://www.aiqiyi.com 自动连接 用&lt;&gt;包起来 1&lt;http://www.baidu.com&gt; 列表 使用*，+，-表示无序列表 123- 无序列表+ 无序列表* 无序列表 有序列表则使用数字接着一个英文句号 1231. 有序列表2. 二3. 三 引用 “&gt;”代表引用(引用的多层嵌套) 123&gt; 引用1&gt;&gt; 应用2&gt;&gt;&gt; 应用3 插入图片1![图片文字](图片地址 &quot;图片title&quot;) //图片文字和标题都可省略 表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐 1234id|name|age-|-|-123|abc|19456|wer|18 分割线 一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西 代码 插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入 使用六个” ` “来包括代码","link":"/2019/06/20/markdown%E8%AF%AD%E6%B3%95/"},{"title":"了解一下Redis","text":"Redis支持以下五种类型 String list set SortedSet Hash 键的过期时间 设置键的生存时间可以通过EXPIRE或者PEXPIRE 设置键的过期时间可以通过EXPIREAT或者PEXPIREAT 其实EXPIRE、PEXPIRE、EXPIREAT这三个命令都是通过PEXPIREAT命令来实现的 过期策略 过期键是保存在哈希表中了。那这些过期键到了过期的时间，就会立马被删除掉吗？？ 删除策略可以分为三种： 定时删除(对内存友好，对CPU不友好) 到时间点上就把所有过期的键删除了 惰性删除(对CPU极度友好，对内存极度不友好) 每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除 定期删除(折中) 每隔一段时间去删除过期键，限制删除的执行时长和频率。 Redis采用的是惰性删除+定期删除两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！ Redis持久化 Redis提供两种不同的持久化方法来将数据存储到硬盘里面： RDB(基于快照)，将某一时刻的所有数据保存到一个RDB文件中。 AOF(append-only-file)，当Redis服务器执行写命令的时候，将执行的写命令保存到AOF文件中。 RDB(快照持久化) 流程： 数据库状态 –保存—–》 RDB文件 数据库状态 《—-还原— RDB文件 有两个命令可以生成RDB文件： SAVE会阻塞Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止 BGSAVE创建出一个子进程，由子进程来负责创建RDB文件，服务器进程可以继续接收请求。 Redis服务器在启动的时候，如果发现有RDB文件，就会自动载入RDB文件(不需要人工干预) 服务器在载入RDB文件期间，会处于阻塞状态，直到载入工作完成。 除了手动调用SAVE或者BGSAVE命令生成RDB文件之外，我们可以使用配置的方式来定期执行 123save 900 1 #在900秒(15分钟)之后，至少有1个key发生变化，save 300 10 #在300秒(5分钟)之后，至少有10个key发生变化save 60 10000 #在60秒(1分钟)之后，至少有10000个key发生变化 AOF(文件追加) 流程： 客户端 —发送写的命令—-》服务器 —-保存被执行的写命令—–》AOF文件 AOF持久化功能的实现可以分为3个步骤： 命令追加：命令写入aof_buf缓冲区 文件写入：调用flushAppendOnlyFile函数，考虑是否要将aof_buf缓冲区写入AOF文件中 文件同步：考虑是否将内存缓冲区的数据真正写入到硬盘 主从框架 主从框架的特点 主服务器负责接受写请求 从服务器负责接收读请求 从服务器的数据由主服务器复制过去。主从服务器的数据是一致的 主从框架的好处： 读写分离(主服务器负责写，从服务器负责读) 高可用(某一台从服务器挂了，其他从服务器还能继续接收请求，不影响服务) 处理更多的并发量(每台从服务器都可以接收读请求，读QPS就上去了) 复制功能主从架构的特点之一：主服务器和从服务器的数据是一致的。 Redis服务器（主） 《———–复制——————- Redis服务器（主） 复制功能分为两个步骤 同步（sync） 将从服务器的数据库状态更新至主服务器的数据库状态 命令传播(command propagate) 主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致，让主从服务器的数据库状态重新回到一致状态。 从服务器对主服务器的同步又可以分为两种情况： 初次同步：从服务器没有复制过任何的主服务器，或者从服务器要复制的主服务器跟上次复制的主服务器不一样。 断线后同步：处于命令传播阶段的主从服务器因为网络原因中断了复制，从服务器通过自动重连重新连接主服务器，并继续复制主服务器 哨兵(Sentinal)机制​ 哨兵机制可以监控，但主服务器瘫痪了之后，可以指定一台从服务器为新的主服务器,如果旧的主服务器接上来，那么旧的主服务器成为了从服务器 缓存雪崩什么是缓存雪崩？ 如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。 这就是缓存雪崩： Redis挂掉了，请求全部走数据库。 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。 缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！ 解决方法​ 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 ​ 对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路 事发前：实现Redis的高可用（主从框架+Sentinel(哨兵)或者Redis Cluster）,尽量避免Redis挂掉这种情况发生。 事发中：万一Redis真的垮了，我们可以设置本地缓存（ehcache）+限流（hystrix）,尽量避免我们的数据库被干掉（起码能保证我们的服务还是能正常工作的） 事发后： redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。 缓存穿透什么是缓存穿透？ 比如数据库后台表的ID都是大于1的书，每次请求的ID都是负数，这会导致我们的缓存不起作用，请求全部都去找数据库了，但数据库也没有这个值，所以每次返回都是空。 缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。 这就是缓存穿透： 请求的数据在缓存大量不命中，导致请求走数据库。 缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！ 解决方法解决缓存穿透的两种方案： 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！ 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。 这种情况我们一般会将空对象设置一个较短的过期时间。","link":"/2019/08/25/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BRedis/"},{"title":"代理（Proxy）","text":"动态代理技术是整个java技术中最重要的一个技术，它是学java框架的基础，在Spring框架中广泛使用 动态代理技术就是用来产生一个对象的代理对象 代理对象存在的价值主要用于拦截对真实业务对象的访问 代理对象应该具有和目标对象（真实业务对象）相同的方法 java中的代理通过java.lang.reflect.Proxy 类提供的一个newProxyInstance方法来串讲一个对象的代理对象想要生成某一个对象的代理对象，这个代理对象也要编写一个类来生成 12345参数解析： first arg:ClassLoader loader用来指明生成代理对象使用哪个类加载器 second arg:Class&lt;?&gt;[] interfaces用来指明生成哪个对象的代理对象，通过接口指定 third arg:InvocationHandler h用来指明产生的这个dialing对象要做什么事情static Object newProxyInstance(ClassLoader loader,class&lt;?&gt;[] interfaces,InvocationHandler h) 编写生成代理对象的类在java中规定，要想产生一个对象的代理对象，那么这个对象必须要有一个接口 例子：(要想为一个类生成一个代理对象，前提是这个类必须要有一个接口，比如下面的AbcMan就有一个Person接口) 1234public interface Person{ String sing(String name); String dance(String name);} 123456789public class AbcMan implements Person{ public String sing(String name){ return &quot;sing a&quot;+name+&quot;song&quot;; } public String dance(String name){ return &quot;dance&quot;+name; }} 创建生成代理对象的代理类123456789101112131415161718192021222324252627282930public class AbcManProxy{ //设计一个类变量记住代理类要代理的目标对象 private Person abc = new AbcMan(); //设计一个方法生成代理对象 public Person getProxy(){ return (Person)Proxy.newProxyInstance(AbcManProxy.class.getClassLoader(),abc.getClass().getInterfaces(),new InvocationHandler(){ /* 参数解析： first arg:把代理对象自己传递进来 second arg:把代理对象当前调用的方法传递进来 third arg:把方法参数传递进来 */ @Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{ //如果调用的是代理对象的sing方法 if(method.getName().equals(&quot;sing&quot;)){ System.out.println(&quot;这里由代理类做一些操作sing&quot;); return method.invoke(abc,args);//代理对象调用真实目标对象的sing方法去处理用户请求 } if(method.getName().equals(&quot;dance&quot;)){ System.out.println(&quot;由代理类做一些操作dance&quot;); return method.invoke(abc,args); } return null； } })； } } 测试： 1234567891011121314151617181920public Class Test{ public static void main(String[] args){ AbcManProxy proxy = new AbcManProxy(); //获取代理对象 Person p = proxy.getProxy(); //调用代理对象的sing方法 String singstr = p.sing(&quot;aaa&quot;); System.out.println(singstr); //调用代理对象的dance方法 String dancestr = p.dance(&quot;bbb&quot;); System.out.println(dancestr); }}-----输出的结果为：这里由代理类做一些操作singsing a aaa song //目标方法执行由代理类做一些操作dancedance bbb 静态代理模式123public interface Person{ void sing();} 静态代理需要创建接口实现类和代理类，这两个类分别实现这个接口 123456public class Abc implements Person{ @Override public void sing(){ System.out.println(&quot;Abc高歌一曲&quot;); }} 12345678910111213public class ProxyAbc implements Person{ //接收实现类对象 private Person p; //通过构造方法传进来实现类对象 public ProxyAbc(Person p){ this.p = p; } @Override public void sing(){ System.out.println(&quot;代理类做的操作&quot;); this.p.sing(); }} 静态代理测试： 1234567public class Test{ public static void main(String [] args){ Person abc = new Abc(); Person proxy = new ProxyAbc(abc); proxy.sing(); }} JDK动态代理 动态代理不需要创建代理类，只需要编写一个动态处理器即可 12345678910111213141516171819202122232425262728public class JdkProxyHandler{ //用来接收实现类对象 private Object abc; //通过构造方法传进来实现类对象 public JdkProxyHandler(Person p){ super(); this.abc = p; } //为实现类对象创建一个代理对象的实例 public Object getProxyInstance(){ /* 参数解析： first arg:指定当前目标对象使用的类加载器 second arg: 指定目标对象实现的接口的类型 third arg: 指定动态处理器 */ return Proxy.newProxyInstance(abc.getClass().getClassLoader(),abc.getClass().getInterfaces(),new InvocationHandler(){ @Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{ System.out.printn(&quot;代理做一些相应的操作&quot;); Object object = method.invoke(abc,args); return obejct； } }); }} JDK动态代理测试： 1234567public class Test{ public static void main(String [] args){ Person abc = new Abc(); Person proxy = new JdkProxyHandler(abc).getProxyInstance(); proxy.sing(); }} CGLIB动态代理JDK动态代理需要实现类通过接口定义方法，那对于没有实现接口的类就使用了CGLIB动态代理来实现 1234567891011121314151617181920212223public class CglibProxyHandler implements MethodInterceptor{ //维护目标对象 private Object target; public Object getProxyInstance(final Object target){ this.target = target; // Enhancer类是CGLIB中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展 Enhancer enhancer = new Enhancer(); // 将被代理的对象设置成父类 enhancer.setSuperclass(this.target.getClass()); // 回调方法，设置拦截器 enhancer.setCallback(this); // 动态创建一个代理类 return enhancer.create(); } @Override public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;代理做一些操作&quot;); Object result = methodProxy.invokeSuper(object, args); return result; }} 使用 CGLIB 需要实现 MethodInterceptor 接口，并重写intercept 方法，在该方法中对原始要执行的方法前后做增强处理。该类的代理对象可以使用代码中的字节码增强器来获取 JDK动态代理测试： 1234567public class Test{ public static void main(String [] args){ Person abc = new Abc(); Person proxy = new CglibProxyHandler().getProxyInstance(abc); proxy.sing(); }} JDK 动态代理和 CGLIB 动态代理均是实现 Spring AOP 的基础 如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP；如果目标对象没有实现了接口，则采用 CGLIB 库，Spring 会自动在 JDK 动态代理和 CGLIB 动态代理之间转换。","link":"/2019/07/15/%E4%BB%A3%E7%90%86(Proxy)/"},{"title":"常见的设计模式","text":"单例模式 构造方法私有化 在类的内部创建实例 提供获取唯一实例的方法 单例模式分为懒汉式和饿汉式 懒汉式(要用的时候才创建) 12345678910111213141516171819public class Demo { // 1.将构造函数私有化，不可以通过new的方式来创建对象 private Demo(){} // 2.先不创建对象，等用到的时候再创建 private static Demo demo = null; // 3.调用到这个方法了，证明是要被用到的了 public static Demo getInstance() { // 4. 如果这个对象引用为null，我们就创建并返回出去 if (demo == null) { demo = new Demo(); } return demo; }} 懒汉式单例模式的实现没有考虑线程安全问题，它的线程是不安全的，并发环境下很可能出现多个Singleton实例 在getInstance方法上加同步 123456789public static synchronized Demo getInstance() { // 4. 如果这个对象引用为null，我们就创建并返回出去 if (demo == null) { demo = new Demo(); } return demo; } 双重检查锁定 123456789101112131415161718192021222324252627282930313233public class Demo { // 1.将构造函数私有化，不可以通过new的方式来创建对象 private Demo(){} // 2.先不创建对象，等用到的时候再创建 private volatile static Demo demo; public static Demo getInstance() { // 3. 如果这个对象引用为null，我们就创建并返回出去 if (demo == null) { synchronized(Demo.class){ if(demo == null){ demo = new Demo(); } } } return demo; }}并发编程的三个概念：1. 原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。2. 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。3. 有序性：即程序执行的顺序按照代码的先后顺序执行。当变量改变时，会立即存入高速缓存中注意：volatile的两个作用：1. 保证变量在多线程下的可见性2.限制编译器指令重排（禁止指令重排序）但volitile不保证原子性 静态内部类 123456789public class Demo { private static class LazyHolder { private static final Demo DEMO = new Demo(); } private Demo (){} public static final Demo getInstance() { return LazyHolder.DEMO; } } 饿汉式例子（不管有没有这个实例都创建一个对象） 123456789101112public class Demo{ // 1.将构造函数私有化，不可以通过new的方式来创建对象 private Demo(){} // 2.在类的内部创建自行实例 private static Demo demo = new Demo(); // 3.提供获取唯一实例的方法(静态工厂方法) public static Demo getInstance() { return demo; }} 工厂模式工厂模式分为三种：简单工厂模式/静态工厂模式、工厂方法模式、抽象工厂模式 需要有工厂类以及对象类 1. 简单工厂模式/静态工厂模式将对象实例化代码抽取到工厂中 1234567891011121314151617181920212223242526272829303132333435363738abstract class Animal{ public abstract String getName();}class Cat extends Animal{ public String getName(){ return &quot;I'm cat&quot;; }}class Dog extends Animal{ public String getName(){ return &quot;I'm dog&quot;; }}... pigclass SimpleFactory { public static Animal createInstance(String type) { if (&quot;cat&quot;.equals(type)) { return new Cat(); } else if (&quot;dog&quot;.equals(type)) { return new Dog(); } else if (&quot;pig&quot;.equals(type)) { return new Pig(); } else { throw new RuntimeException(&quot;type[&quot; + type + &quot;]类型不可识别，没有匹配到可实例化的对象！&quot;); } }}public class Demo { public static void main(String[] args) { Cat cat = SimpleFactory.createInstance(&quot;cat&quot;); System.out.println(&quot;创建的动物实例为:&quot; + cat.getName()); Dog dog = SimpleFactory.createInstance(&quot;dog&quot;); System.out.println(&quot;创建的动物实例为:&quot; + dog.getName()); }} 缺点：如果要生产其他动物，需要添加具体类以及修改工厂类 2. 工厂方法模式定义了一个创建对象的接口，由子类决定要实例化的类是哪一个，工厂方法让类吧实例化推迟到子类 1234567891011121314151617181920212223242526272829303132333435abstract class AnimalFactory { public abstract Animal[] createAnimal();}//猫工厂class CatFactory extends AnimalFactory { @Override public Animal[] createAnimal() { return new Animal[]{new WhiteCat(), new BlackCat()}; }}// 狗工厂class DogFactory extends AnimalFactory { @Override public Animal[] createAnimal() { return new Animal[]{new WhiteDog(), new BlackDog()}; }}public class Demo { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory; Animal[] cats = catFactory.createAnimal(); System.out.println(&quot;生产的猫的有：&quot;); print(cats); } static void print(Animal[] a) { for (Animal al : a) { System.out.println(al.getName()); } }} 3. 抽象工厂模式提供一个接口，英语创建相关或者依赖对象的家族，而不需要明确制定具体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354abstract class Animal { public abstract String getName();}abstract class Cat extends Animal {}abstract class Dog extends Animal {}class WhiteCat extends Cat { @Override public String getName() { return &quot;白猫&quot;; }}class BlackDog extends Dog { @Override public String getName() { return &quot;黑狗&quot;; }}interface AbstractAnimalFactory { Cat createCat(); Dog createDog();}class AnimalFactory implements AbstractAnimalFactory { @Override public Cat createCat(){ return new WhiteCat(); } @Override public Dog createDog(){ return new BlackDog(); }}public class Demo { public static void main(String[] args) { AbstractAnimalFactory animalFactory = new AnimalFactory(); Cat cat = animalFactory.createCat(); Dog dog = animalFactory.createDog(); System.out.println(cat.getName()); System.out.println(dog.getName()); }} …未完待续","link":"/2019/07/09/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"erlang异常处理","text":"频繁出现timeout1、执行top查看CPU是否占用满了 2、查看哪些进程占用资源比较大 ​ 在交互（终端)下，执行 1234spawn(fun() -&gt; etop:start([{interval,10},{sort,runtime}]) end).% 退出etopetop:stop() 定位模块解决问题 开发服编译器占用(后台卡住)1、执行以下命令查看哪些命令在执行 1ps aws | grep dev.sh 2、执行以下命令直接kill某些进程,除了 grep –color dev.sh 1kill -9 psId(对应的进程id)","link":"/2024/03/15/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"游戏装服流程","text":"一、中央服装服流程需要将基础环境搭建好才能进行以下操作 123456mysql 5.6.13mongodb 3.6.12nginx (稳定版本)php 7.3.10(启动php-fpm)redis 7.0.11erlnag25(otp_src_25.2.1) 1、搭建redis依赖(需要支持持久化)1234567891011121314151617181920212223242526272829303132# 创建目录mkdir /data/redis/33379/{conf,data,logs} -p# 配置cp -a /usr/local/redis-7.0.11/redis.conf /data/redis/33379/conf/# 修改/data/redis/33379/conf/redis.conf配置---- 33379 ----bind 127.0.0.1protected-mode yes #开启保护模式port 33379 #端口pidfile /var/run/redis_33379.pid #进程idlogfile /data/redis/33379/logs/redis-server.log #日志dir /data/redis/33379/data/ #数据目录repl-diskless-sync noappendonly yes #开启持久化requirepass zusI9fuCMI5eHP2X #设置密码 rename-command FLUSHALL &quot;&quot;rename-command CONFIG &quot;&quot;rename-command EVAL &quot;&quot;# 测试（在/root/目录下创建脚本start-redis.sh)#!/bin/bash/usr/local/redis-7.0.11/bin/redis-server /data/redis/33379/conf/redis.conf &amp;#启动redissh /root/start-redis.sh#连接（因为上面设置了密码、所以也需要密码连接）/usr/local/redis-7.0.11/bin/redis-cli -h 127.0.0.1 -p 33379 -a zusI9fuCMI5eHP2X ping# 返回pong则为成功 2、创建日志目录(存放log目录 server Nginx)1mkdir -p /data/logs 3、中央服3.1、创建目录1mkdir /data/wxh5_center_f001a/{mysql,mongodb,html/hhsy,sh,server,DBCombine} -p 3.2、mysql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 2.1、切换到mysql目录cd /data/wxh5_center_f001a/mysql# 2.2、拉取mysql文件(从外网服获取相应的脚本)close-mysql.shfswr_mdata.tgzmysqldump.shmysql_install_fswr.shportstart-mysql.shmy.cnf# sql文件# 2.3、编写mysql的端口echo 33001 &gt; port# 2.4、安装(mysql实例)bash mysql_install_fswr.sh master# 2.5、检查端口是否正常启动netstat -ntlup | grep `cat port`# 2.6、修改mysql密码# 需要将数据库密码写入 /usr/local/mysql/docs/help 中（第一行为内网的密码，第二行为正式服用的密码)/usr/local/mysql/bin/mysql -h127.0.0.1 -P`cat port` -uroot -p`sed -n 1p /usr/local/mysql/docs/help`# 这个密码在安装mysql的时候就已是设置到mysq.user表中# 装服内网的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'abc123456' WITH GRANT OPTION;flush privileges;# 装服正式服的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;UPDATE user SET Password = password('test123456') WHERE User='root';flush privileges;# 2.7、导表# 创建muti_lang_center数据库create database muti_lang_center default character set utf8;# 导入表数据# 内网用# /usr/local/mysql56/bin/mysql -uroot -p`sed -n 1p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port)/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; muti_lang_center.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_current.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_lang.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_menu.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_permit.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_user_group.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_user.sql 3.3、mongodb123456789101112131415161718# 3.1、切换目录cd /data/wxh5_center_f001a/mongodb# 3.2、所需的文件(从外网服获取相应的脚本)close_mongodb_master_by_pidfile.shmongodump.shportstart_mongodb_master.shmongodb.conf# 3.3、编写mongodb端口 echo 23001 &gt; port# 3.4、启动mongodbbash start_mongodb_master.sh# 3.5、检查端口是否正常启动netstat -ntlup | grep `cat port` 3.4、html (从gitlab中的phpServer中拉取）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 4.1、需要php代码文件 /data/wxh5_center_f001a/html/hhsy/ -center/ -cluster/ -server/ -single/ -sy_extends/ (这个不用，目前用不上)# 4.2、切换目录/data/wxh5_center_f001a/html# 4.3、修改所属用户和组chown -R www.www hhsy/# 4.4、修改配置文件hhsy/center/application/database.phphhsy/cluster/application/database.php----------start----------------return [ // 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '127.0.0.1', //线上 10.20.1.1 // 数据库名 ‘database’ =&gt; 'muti_lang_center', // 用户名 'username' =&gt; 'root', // 密码 'password' =&gt; 'abc123456', // 正式服用 test123456 // 端口 'hostport' =&gt; '33001']--------------end------------hhsy/center/application/config.phphhsy/cluster/application/config.php----------start----------------# 以新配置为准'mongo_config_login' =&gt; [ // 主库 ‘master’ =&gt; [ // mongo主机内网ip 'inside_host' =&gt; '127.0.0.1', // mongo主机 'host' =&gt; '23002' ], // 从库 'slave' =&gt; [ // mongo主机 'host' =&gt; '127.0.0.1', // mongo端口 'port' =&gt; '23001' ]]----------end------------------# 4.5、修改标题hhsy/center/application/admin/view/common/header.html# 4.6、赋予目录权限chmod -R 777 hhsy/center/runtimechmod -R 777 hhsy/cluster/runtime 3.5、fastcgi修改配置文件 /usr/local/php7.3.10/etc/php-fpm.d/www.conf 12345pm = dynamicpm.max_children = 600pm.start_servers = 30pm.min_spare_servers = 30pm.max_spare_servers = 400 重启fastcgi 12bash /root/fastcgi_kill_all.shbash /root/fastcgi_start.sh 3.6、Nginx配置需要SSL证书 /usr/local/nginx/conf/vhost/wxh5-center.gameone.com.conf （文件名称视具体域名来定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364server{ listen 9480; listen 9443 ssl; server_name wxh5-data.gameone.com; # 这个视具体的域名来定 root /data/wxh5_center_f001a/html/hhsy/center/public/; index index.html index.htm index.php; charset utf-8; proxy_ignore_client_abort on; expires 2h; ssl_certificate ssl/gameone.com.pem; ssl_certificate_key ssl/gameone.com.key; ssl_protocols SSLv2 SSLv3 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; client_max_body_size 100m; location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ~ .*\\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; expires off; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.swf$ { expires 72h; } location ~ .*\\.css$ { expires 96h; } location ~ .*\\.xml$ { expires 12h; } location ~ .*\\.js$ { expires 96h; } location ~ .*\\.jpg$ { expires 96h; } location ~ .*\\.gif$ { expires 96h; } location ~ .*\\.png$ { expires 96h; } location ~ .*\\.mp3$ { expires 400h; } location ~ /\\.svn/ { return 403; } location ~* \\.(sh|log|sh|sql|svn|tar|gz|svn-base) { root ~; deny all; } access_log /data/logs/wxh5-center.log;} /usr/local/nginx/conf/vhost/wxh5-data.gameone.com.conf （文件名称视具体域名来定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364server{ listen 8480; listen 8443 ssl; server_name wxh5-data.gameone.com; # 这个视具体的域名来定 root /data/wxh5_center_f001a/html/hhsy/cluster/public/; index index.html index.htm index.php; charset utf-8; proxy_ignore_client_abort on; expires 2h; ssl_certificate ssl/gameone.com.pem; ssl_certificate_key ssl/gameone.com.key; ssl_protocols SSLv2 SSLv3 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; client_max_body_size 100m; location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ~ .*\\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; expires off; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.swf$ { expires 72h; } location ~ .*\\.css$ { expires 96h; } location ~ .*\\.xml$ { expires 12h; } location ~ .*\\.js$ { expires 96h; } location ~ .*\\.jpg$ { expires 96h; } location ~ .*\\.gif$ { expires 96h; } location ~ .*\\.png$ { expires 96h; } location ~ .*\\.mp3$ { expires 400h; } location ~ /\\.svn/ { return 403; } location ~* \\.(sh|log|sh|sql|svn|tar|gz|svn-base) { root ~; deny all; } access_log /data/logs/wxh5-data.log;} 配置完成后重新启动Nginx 1bash /root/nginx_reload.sh 3.7、定时任务1230 */1 * * * sh /data/wxh5_center_f001a/html/hhsy/center/application/crontab/crontab_1_minutes.sh 1&gt;&amp;2 2&gt;/dev/null0 5 * * * sh /data/wxh5_center_f001a/html/hhsy/center/application/crontab/crontab_5.00_am.sh 1&gt;&amp;2 2&gt;/dev/null*/1 * * * * sh /data/wxh5_center_f001a/html/hhsy/center/application/crontab/crontab_5_minutes.sh 1&gt;&amp;2 2&gt;/dev/null 3.8、测试1https://wxh5-data.gameone.com:9443/admin/index/index //后台 4、IdServer服idServer 此服务需要Redis支持,所有游戏服要内网能访问到此服务。 拷贝目录下面的confg.cnf配置端口和redis连接地址。此redis需要持久化 要redislog持久化操作，保证数据可还原. 12345678910111213141516171819202122232425262728# 1、拉取资源 (从外网服拉）mkdir -p /data/idServer/ rsync -e &quot;ssh -p22-azvP ip:/data/idServer/* /data/idServer/# 2、配置(config.cnf)---------start-----------db=127.0.0.1:33379pass=zusI9fuCMI5eHP2X # 启动redis配置的密码port=:52888-----------end---------# 3、启动# 如果没有安装screen 则先安装 yum -y install screen# 执行这个命令先将redis启动起来# sh startRedis.shscreen -S idServer # 创建 screen./idserver &amp; # 启动后关闭终端（使用快捷键Ctrl+A+D, 关闭窗口即可实现程序的后台运行）# 设置玩家初始id# 连接上redis/usr/local/redis-7.0.11/bin/redis-cli -h 127.0.0.1 -p 33379 -a zusI9fuCMI5eHP2Xselect 1 #选择数据库1keys * # 查看所有的key 会出现 “/1&quot; 这个就是key值get /1 // 可以查看当前的&quot;/1&quot; 对应的值为多少set /1 10000000 // 设置 key“/1” 的值#与redis断开连接quit // 输入指令 二、游戏服装服流程（在游戏服中的操作）1、创建目录1mkdir -p /data/mcwx_mixed_s001a/{html/hhsy/,mysql,server,sh} 2、mysql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 2.1（从中央服获取脚本）cd /data/mcwx_mixed_s001a/mysql/rsync -azvP 172.20.30.6{中央服ip}:/data/wxh5_center_f002a/mysql/{*.sh,port,fswr_mdata.tgz,my.cnf} ./rsync -azvP 43.154.100.178{中央服ip}:/data/ghzslg_release/20230518/{all_null_*,entry_all.sql} ./# 2.2、修改端口echo 32001 &gt; port# 2.3、安装mysql实例bash mysql_install_fswr.sh master# 2.3、检查端口是否正常启动netstat -tunpl | grep `cat port`# 2.4、创建数据库# 需要将数据库密码写入 /usr/local/mysql/docs/help 中（第一行为内网的密码，第二行为正式服用的密码)/usr/local/mysql/bin/mysql -h127.0.0.1 -P`cat port` -uroot -p`sed -n 1p /usr/local/mysql/docs/help`# 装服内网的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'abc123456' WITH GRANT OPTION;flush privileges;# 装服正式服的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;UPDATE user SET Password = password('test123456') WHERE User='root';flush privileges;# 这个密码在安装mysql的时候就已是设置到mysq.user表中# 内网用/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 1p /usr/local/mysql/docs/help` -P$(cat port)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_admin&quot;/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_game&quot;# 2.5、导表 (mxqy_game)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_game &lt; ./all_null_table.sql # 2.6、插入sql语句（注意里面的ip为中央服的ip地址）/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P`cat port` mxqy_gameINSERT INTO `serverUrl` VALUES ('1', 'http://172.20.30.12(中央服ip):52888/1', '1');INSERT INTO `serverUrl` VALUES ('13', 'http://172.20.30.12(中央服ip):52888/test', '1');# 2.7、导表（mxqy_admin)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_admin &lt; ./all_null_admin.sql# 2.8、授权/usr/local/mysql56/bin/mysql -uroot -p$(sed -n 2p /usr/local/mysql/docs/help) -h127.0.0.1 -P$(cat port) -e &quot;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;&quot;/usr/local/mysql56/bin/mysql -uroot -p$(sed -n 2p /usr/local/mysql/docs/help) -h127.0.0.1 -P$(cat port) -e &quot;flush privileges;&quot;# 2.9、插入开服日期/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) insert into mxqy_game.serverConfig values (202,1,'2024-05-20'); 格式：202，server_id,开服日期 3、html1234567# 3.1、从中央服拉rsync -azvP 172.20.30.6{中央服ip}:/data/wxh5_center_f001a/html/hhsy/{single,server} /data/mcwx_mixed_s001a/html/hhsy/# 3.2、配置（修改端口和密码）chown www.www -R html/# 后台设置同步过来vim /data/mcwx_mixed_s001a/html/hhsy/single/config/database.php #mysql 4、server1234567891011121314151617# 从外网服拉取# 4.1 修改配置 （连接数据配置的修改）/data/mcwx_mixed_s001a/server/config/server.app# 4.2 修改启动脚本/data/mcwx_mixed_s001a/server/sh/main.shNUM=100 # 1服 (服id*100)# 4.3 需要获得最新的ebin文件# 4.4 启动cd /data/mcwx_mixed_s001a/server/sh/bash main.sh start# 4.5 检查netstat -tunpl | grep 10501 # 这个端口为上面配置端口+1 5、添加nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server{ listen 4001; # 服id + 4000 server_name 43.154.183; # 对应的ip地址 root /data/mcwx_mixed_s001a/html/hhsy/single/public; index index.html index.htm index.php; add_header Access-Control-Allow-Origin *; charset utf-8; expires -1; client_max_body_size 100m; location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ~ .*\\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; expires off; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.swf$ { expires 72h; } location ~ .*\\.css$ { expires 96h; } location ~ .*\\.xml$ { expires 12h; } location ~ .*\\.js$ { expires 96h; } location ~ .*\\.jpg$ { expires 96h; } location ~ .*\\.gif$ { expires 96h; } location ~ .*\\.png$ { expires 96h; } location ~ .*\\.mp3$ { expires 400h; } location ~ /\\.svn/ { return 403; } location ~* \\.(txt|sh|xls|doc|log|sh|sql|svn|tar|gz|svn-base) { root ~; deny all; } access_log /data/logs/mcwx_mixed_s001a.log;} 重启nginx 1bash /root/nginx-reload.sh 这个nginx端口需要开放出来 6、去数据后台添加新增的服信息三、跨服路由机1 、创建目录1mkdir /data/mcwx_travel_s99001a/{html,mysql,server,sh} 2 、mysql1234567891011121314151617181920212223242526272829303132#2.1 、拉取文件(**从中央服获取脚本 或者直接从**https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/mysql_sh**获取**)cd /data/mcwx_travel_s99001a/mysql#2.2、修改端口echo 31001 &gt; port# 2.3、安装bash mysql_install_fswr.sh master# 2.4、检查端口是否正常启动netstat -tunpl | grep `cat port`# 2.5、创建数据库#(修改mysql密码 )/usr/local/mysql/bin/mysql -h127.0.0.1 -P`cat port` -uroot -p`sed -n 1p /usr/local/mysql/docs/help`use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;UPDATE user SET Password = password('test123456') WHERE User='root';flush privileges;# 这个密码在安装mysql的时候就已是设置到mysq.user表中/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_admin&quot;/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_game&quot;# 2.6、导表 (mxqy_game)# 获取sql文件（https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/server/sql）/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_game &lt; ./mxqy_game.sql# 2.7、导表（mxqy_admin)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_admin &lt; ./mxqy_admin.sql 3、server1234567891011121314151617181920# 获取（https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/server)# 3.1 修改配置 （连接数据配置的修改）/data/mcwx_mixed_s001a/server/config/server.appserverId = 99001 # 99000+1port = 35001server.app多了一个 serverType配置，路由机的类型是3 ，工作机的类型是4其他跟之前一样# 3.2 修改启动脚本/data/mcwx_travel_s99001a/server/sh/main.shnum=9900100 # 服id*100# 3.2 获取最新的ebin文件从（https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/server/ebin 获取）# 3.3 启动cd /data/mcwx_mixed_s001a/server/sh/bash main.sh start 工作机1、创建目录1mkdir /data/ghzslg_travel_s99002a/ 2、mysql2.1 拉取文件1rsync -azvP 172.20.30.6:/data/ghzslg_center_f001a/mysql/{*.sh,port,fswr_mdata.tgz,*.sql,my.cnf} /data/ghzslg_travel_s99002a/mysql/ 2.2 切换目录1echo 31001 &gt; port 2.4 安装12bash mysql_install_fswr.sh masternetstat -tunpl | grep `cat port` 2.5 检查1netstat -tunpl | grep `cat port` 2.6 配置123跨服server.app多了一个 serverType配置，路由机的类型是3 ，工作机的类型是4其他跟之前一样 需要开发的端口1234567891011121380433# http://192.168.56.101:52888/test# 获得玩家id52888# firewall-cmd --permanent --add-port=80/tcp# firewall-cmd --reload94804008 // 游戏服single 杂项1234# 打包排除 (排除log下的所有文件)tar -zcvf hhsy.tar.gz --exclude=./hhsy/center/runtime/log/* --exclude=hhsy/cluster/runtime/log/* ./hhsy# 打包排除（排除log文件夹）tar -zcvf hhsy.tar.gz --exclude=./hhsy/center/runtime/log --exclude=hhsy/cluster/runtime/log ./hhsy","link":"/2024/05/11/%E6%B8%B8%E6%88%8F%E8%A3%85%E6%9C%8D%E6%B5%81%E7%A8%8B/"},{"title":"获取天气信息","text":"​ 其实获取天气报告之前做android的时候就有做过（之前好像使用JSONObject来解析的），我这边再记录一下使用ajax的方式来获取天气信息，天气预报功能来源于高德地图API和和风天气API组合而成，能够查看当前IP地址所在地的近三日天气，看效果图 来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;获取天气情况&lt;/title&gt; &lt;!--引入JQuery--&gt; &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!--获取天气预报--&gt; &lt;script&gt; $(function(){ /*先获取位置（也就是要获取那个地方的天气：比如广州）、再获取天气预报的信息*/ //使用ajax的方式获取 $.ajax({ /*参数解析： url: 表示访问的地址 type: 请求的方式：get方式 success: 访问成功后执行的方法，里面的参数表示请求返回的对象 */ url: &quot;http://restapi.amap.com/v3/ip?key=11ddf2f282ee4c39d35a46c3a4dae845&quot;, type: &quot;get&quot;, success: function(responseText1){//responseText1为一个json对象 /* 照样使用ajax请求，注意url后面添加了一个参数（根据responseText1获取城市并传递过去） */ $.ajax({ url: &quot;https://free-api.heweather.com/s6/weather/forecast?key=d66df9e9bec5484da78f88a5bb58d092&amp;location=&quot;+responseText1.city, type: &quot;get&quot;, success: function(responseText2){//responseText2照样也是一个json对象 $(&quot;#showForecast h1&quot;).html(responseText1.city+&quot;近三天天气&quot;); //获取responseText2对象里面的HeWeather6（数组），获取第一个对象里面的daily_forecast（数组） var jsonObj = responseText2.HeWeather6[0].daily_forecast; //做遍历 for(var i = 0; i &lt; jsonObj.length; i++){ var date = jsonObj[i].date; var weather = jsonObj[i].cond_txt_d; var low = jsonObj[i].tmp_min; var hight = jsonObj[i].tmp_max; //展示到页面 $(&quot;#showForecast&quot;).append(&quot;&lt;p&gt;&quot;+ date + &quot;:&quot; + weather + &quot;，温度: &quot; + low+ &quot; ~ &quot; + hight + &quot;℃&lt;/p&gt;&quot;); } }, error: function(){ alert(&quot;获取天气失败&quot;); } }); }, error: function(){ alert(&quot;获取定位失败&quot;); } }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--显示天气预报--&gt; &lt;div id=&quot;showForecast&quot; align=&quot;center&quot;&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上的代码已经将功能实现，下面进行解析： 第一个ajax的时候responseText1为一个json对象，内容如下： （可以把地址复制粘贴到浏览器的地址栏就可以看到） 123456789{status: &quot;1&quot;,info: &quot;OK&quot;,infocode: &quot;10000&quot;,province: &quot;广东省&quot;,city: &quot;广州市&quot;,adcode: &quot;440100&quot;,rectangle: &quot;113.1017375,22.93212254;113.6770499,23.3809537&quot;} 这个city是广州，如果想更换成其他的城市，需要更换（http://restapi.amap.com/v3/ip?key=11ddf2f282ee4c39d35a46c3a4dae845）key的值 第二个ajax你可以看到url这个位置传入一个city参数，就是第一个ajax获取的responseText1的city responseText2的内容如下：（主要获取daily_forecast数组的值，然后遍历显示在页面） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889{ HeWeather6: [{ basic: { cid: &quot;CN101280101&quot;, location: &quot;广州&quot;, parent_city: &quot;广州&quot;, admin_area: &quot;广东&quot;, cnty: &quot;中国&quot;, lat: &quot;23.12517738&quot;, lon: &quot;113.28063965&quot;, tz: &quot;+8.00&quot; }, update: { loc: &quot;2019-07-10 10:57&quot;, utc: &quot;2019-07-10 02:57&quot; }, status: &quot;ok&quot;, daily_forecast: [{ cond_code_d: &quot;306&quot;, cond_code_n: &quot;302&quot;, cond_txt_d: &quot;中雨&quot;, cond_txt_n: &quot;雷阵雨&quot;, date: &quot;2019-07-10&quot;, hum: &quot;76&quot;, mr: &quot;13:16&quot;, ms: &quot;00:34&quot;, pcpn: &quot;2.1&quot;, pop: &quot;55&quot;, pres: &quot;1003&quot;, sr: &quot;05:48&quot;, ss: &quot;19:16&quot;, tmp_max: &quot;30&quot;, tmp_min: &quot;25&quot;, uv_index: &quot;1&quot;, vis: &quot;13&quot;, wind_deg: &quot;-1&quot;, wind_dir: &quot;无持续风向&quot;, wind_sc: &quot;1-2&quot;, wind_spd: &quot;10&quot; }, { cond_code_d: &quot;306&quot;, cond_code_n: &quot;104&quot;, cond_txt_d: &quot;中雨&quot;, cond_txt_n: &quot;阴&quot;, date: &quot;2019-07-11&quot;, hum: &quot;70&quot;, mr: &quot;14:13&quot;, ms: &quot;01:14&quot;, pcpn: &quot;5.3&quot;, pop: &quot;65&quot;, pres: &quot;1004&quot;, sr: &quot;05:48&quot;, ss: &quot;19:16&quot;, tmp_max: &quot;31&quot;, tmp_min: &quot;26&quot;, uv_index: &quot;1&quot;, vis: &quot;20&quot;, wind_deg: &quot;-1&quot;, wind_dir: &quot;无持续风向&quot;, wind_sc: &quot;1-2&quot;, wind_spd: &quot;6&quot; }, { cond_code_d: &quot;302&quot;, cond_code_n: &quot;101&quot;, cond_txt_d: &quot;雷阵雨&quot;, cond_txt_n: &quot;多云&quot;, date: &quot;2019-07-12&quot;, hum: &quot;72&quot;, mr: &quot;15:11&quot;, ms: &quot;01:55&quot;, pcpn: &quot;0.0&quot;, pop: &quot;25&quot;, pres: &quot;1003&quot;, sr: &quot;05:49&quot;, ss: &quot;19:15&quot;, tmp_max: &quot;34&quot;, tmp_min: &quot;27&quot;, uv_index: &quot;2&quot;, vis: &quot;24&quot;, wind_deg: &quot;-1&quot;, wind_dir: &quot;无持续风向&quot;, wind_sc: &quot;1-2&quot;, wind_spd: &quot;9&quot; } ] }]} 第二个ajax的用法在代码中已有注释 背景： 嗯，下面来介绍一下上面的背景吧，这个也是偶尔看到的，也非常的简单实用，让背景不再单调 项目github地址为：https://github.com/VincentGarreau/particles.js 关于使用看这边文章：https://blog.csdn.net/csdn_yudong/article/details/53128570","link":"/2019/07/10/%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E4%BF%A1%E6%81%AF/"},{"title":"过滤器与监听器","text":"实现一个简单的过滤器我们可以在执行doFilter()方法前做一些预处理 通过xml配置 第一步编写一个类实现 Filter接口 12345678public class FilterDemo implements Filter{ //其中init()和destory()方法跟Servlet一样，只有在Web服务器加载和销毁的时候才被执行，只会执行一次 public void destory(){} public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws ServletException, IOException { chain.doFilter(req,resp)；//执行这个表示为放行 }} 第二步 filter的部署(在web.xml文件中配置) 123456789101112&lt;filter&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;&lt;!--过滤器名称--&gt; &lt;filter-class&gt;com.heclam.FilterDemo&lt;/filter-class&gt;&lt;!--限定类名--&gt; &lt;init-param&gt;&lt;!--过滤器初始化参数--&gt; &lt;param-name&gt;testFile&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/abc.txt&lt;/param-value&gt; &lt;/init-param&gt; &lt;filter-mapping&gt;&lt;!--用于拦截资源--&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;&lt;!--与上面的名称一致--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--拦截请求路径--&gt; &lt;/filter-mapping&gt;&lt;/filter&gt; 通过注解配置12@WebFilter(filterName=&quot;FilterDemo2&quot;,urlPatterns=&quot;/*&quot;)public filterDemo2 implements Filter{} 监听器Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁、或者往其中添加修改删除属性时自动执行代码的功能组件。 ServletContextListener : 对Servlet上下文的创建和销毁进行监听 ServletContextAttributeListener ：监听Servlet上下文属性的添加、删除和替换 HttpSessionListener HttpSessionAttributeListener ServletRequestListener ServletRequestAttributeListener Servlet3从Servlet3开始，Servlet3提供了基于注解的部署方式，可以分别使用WebServlet、WebFilter、WebListener进行部署servlet、过滤器、监听器","link":"/2019/07/09/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"}],"tags":[{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"erlang","slug":"erlang","link":"/tags/erlang/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"JDk","slug":"JDk","link":"/tags/JDk/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"mnesia","slug":"mnesia","link":"/tags/mnesia/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Spring事务","slug":"Spring事务","link":"/tags/Spring%E4%BA%8B%E5%8A%A1/"},{"name":"batch","slug":"batch","link":"/tags/batch/"},{"name":"contab","slug":"contab","link":"/tags/contab/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"java线程","slug":"java线程","link":"/tags/java%E7%BA%BF%E7%A8%8B/"},{"name":"linux - screen","slug":"linux-screen","link":"/tags/linux-screen/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"gameServer","slug":"gameServer","link":"/tags/gameServer/"},{"name":"新技能","slug":"新技能","link":"/tags/%E6%96%B0%E6%8A%80%E8%83%BD/"},{"name":"过滤器","slug":"过滤器","link":"/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"监听器","slug":"监听器","link":"/tags/%E7%9B%91%E5%90%AC%E5%99%A8/"}],"categories":[{"name":"javaWeb","slug":"javaWeb","link":"/categories/javaWeb/"},{"name":"erlang","slug":"erlang","link":"/categories/erlang/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"batch","slug":"batch","link":"/categories/batch/"},{"name":"contab","slug":"contab","link":"/categories/contab/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"gameServer","slug":"gameServer","link":"/categories/gameServer/"}],"pages":[{"title":"about","text":"keep move!","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}