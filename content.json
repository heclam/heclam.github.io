{"posts":[{"title":"Ajax","text":"当我们使用AJAX之后，浏览器是先把请求发送到XMLHttpRequest异步对象之中，异步对象对请求进行封装，然后再与发送给服务器。服务器并不是以转发的方式响应，而是以流的方式把数据返回给浏览器 XMLHttpRequest异步对象会不停监听服务器状态的变化，得到服务器返回的数据，就写到浏览器上【因为不是转发的方式，所以是无刷新就能够获取服务器端的数据】 XMLHttpRequest对象1234567891011function getXHR() { //根据对象判断浏览器 if(window.XMLHttpRequest) { //不是IE return new XMLHttpRequest(); }else{ //IE return new ActiveXObject(&quot;Microsoft.XMLHttp&quot;); }}var xhr = getXHR(); get方式请求12345//参数解析： 第一个参数：表示请求的方式 第二个参数：表示请求的地址 第三个参数：表示是否为异步请求（true表示发送异步请求）xhr.open(&quot;get&quot;, url, true); 发送请求1xhr.send(null); 回调函数XHR 对象的readyState 属性可取的值： 0：未初始化。尚未调用open()方法。 1：启动。已经调用open()方法，但尚未调用send()方法。 2：发送。已经调用send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 只要readyState 属性的值由一个值变成另一个值，都会触发一次readystatechange 事件。可以利用这个事件来检测每次状态变化后readyState 的值。 12345678xhr.onreadystatechange = function(){ //当请求结束且没报错时 if(xhr.readyState==4 &amp;&amp; xhr.status==200) { var txt = xhr.responseText; console.log(txt); }}; responseText:作为响应主体被返回的文本 responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM 文档。 post请求123456789101112xhr.open(&quot;post&quot;,url, true);//设置请求头xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//发送form表单数据var form = document.getElementById(&quot;form&quot;);//发送序列化的表单xhr.send(serialize(form));//发送普通数据xhr.send(&quot;name = abc&quot;);xhr.send(&quot;book = JavaScript&quot;); $.ajax()语法： $.ajax({key:value,key:value}) 例如： 1234567891011121314151617181920$.ajax({ type: &quot;GET&quot;, //String类型参数，请求方式POST或GET,默认为GET,请求方式 url: &quot;xxx&quot;, //String类型参数，发送请求的地址 async: true, //Boolean类型参数，表示为异步请求，默认为true cache: false, //Boolean类型参数，是否设置缓存,默认为false contentType: xxx, //发送信息至服务器时内容编码类型 data: String , //Object或String类型参数，发送到服务器的数据，比如为&quot;json&quot; dataType: String, //String类型参数，服务器返回的数据类型 success: function(data){}//成功回调的函数 error:function(data){} //失败回调函数});","link":"/2019/06/26/Ajax/"},{"title":"Cookie笔记","text":"何为会话用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 Cookie的流程：浏览器访问服务器，如果服务器需要记录该用户的状态，就使用response向浏览器发送一个Cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同Cookie一同交给服务器。 ​ 创建一个Cookie对象，发送给浏览器 ​ Cookie cookie = new Cookie(key,valus); //创建Cookie对象，指定名称和值 ​ Cookie.setAge(秒); //设置时间 ​ response.addCookie(cookie);//向浏览器发送一个cookie 保存会话数据的两种技术Cookie和Session Cookie API 方法 类型 描述 Cookie(String name ,String value) 构造方法 实例化Cookie对象，传入Cookie名称和Cookie值 public String getName() 普通方法 获取Cookie的名称 public String getValue() 普通方法 获取Cookie的值 public String setValue() 普通方法 设置Cookie的值 public void setMaxAge(int expiry) 普通方法 设置Cookie的有效期，如果expiry为正数，浏览器会把Cookie写入到硬盘中，如果为负数，Cookie是临时的 public int getMaxAge() 普通方法 获取Cookie的有效期 setPaht(String uri) 与getPath() 普通方法 有效路径 setDomain(String pattern)与getDomain() 普通方法 有效域 一个Cookie例子1234567891011121314151617181920212223public class ServletDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置服务器端以UTF-8编码进行输出 response.setCharacterEncoding(&quot;UTF-8&quot;); //设置浏览器以UTF-8编码进行接收,解决中文乱码问题 response.setContentType(&quot;text/html;charset=UTF-8&quot;); //创建一个Cookie对象,并指定名称和值 Cookie cookie = new Cookie(&quot;username&quot;,&quot;abc&quot;); //设置cookie有效期 cookie.setMaxAge(1000); //向浏览器添加一个Cookie response.addCookie(cookie); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 获取Cookie 12345Cookie[] cookies = request.getCookies(); for (int i = 0;cookies! = null &amp;&amp; i &lt; cookies.length; i++) { String name = cookies[i].getName(); String Value = cookies[i].getValue(); } 一些Cookie方法的解析Cookie有效期： 如果MaxAge为正数，浏览器会把Cookie写到硬盘中，只要还在MaxAge秒之前，登陆网站时该Cookie就有效【不论关闭了浏览器还是电脑】 如果MaxAge为负数，Cookie是临时性的，仅在本浏览器内有效，关闭浏览器Cookie就失效了，Cookie不会写到硬盘中。Cookie默认值就是-1。 如果MaxAge为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie对应的方法，把MaxAge设置为0等同于删除Cookie Cookie中存取中文123456//Cookie存储中文的时候需要使用URLEncoder类里面的encode(String s,String enc)方法进行中文转码Cookie cookie = new Cookie(&quot;userName&quot;, URLEncoder.encode(&quot;孤傲苍狼&quot;, &quot;UTF-8&quot;));response.addCookie(cookie);//获取Cookie中的中文，需要使用URLEncoder类里面的decode(String s,String enc)进行解码URLDecoder.decode(cookies[i].getValue(), &quot;UTF-8&quot;)","link":"/2019/07/08/Cookie%E7%AC%94%E8%AE%B0/"},{"title":"JSP笔记","text":"何为JSP ？ JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。 JSP这门技术的最大的特点在于，写jsp就像在写html，但它相比html而言，html只能为用户提供静态数据，而Jsp技术允许在页面中嵌套java代码，为用户提供动态数据。 JSP原理浏览器向服务器发请求，不管访问的是什么资源，其实都是在访问Servlet，所以当访问一个jsp页面时，其实也是在访问一个Servlet，服务器在执行jsp的时候，首先把jsp翻译成一个Servlet，所以我们访问jsp时，其实不是在访问jsp，而是在访问jsp翻译过后的那个Servlet 为什么有了Servlet了还需要JSP呢？其实JSP的出现是简化了Servlet，之前我们要展示一个页面要在Servlet中写 1234out.write(&quot;&lt;html&gt;&quot;);out.write(&quot;&lt;body&gt;&quot;);out.write(&quot;&lt;/body&gt;&quot;);out.write(&quot;&lt;/html&gt;&quot;); 之类的代码，显得太过麻烦了，所以就出现了JSP。 JSP的生命周期jsp的生命周期类似于servlet的生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。 JSP生命周期的阶段： 编译阶段(解析JSP文件，将JSP文件转换为servlet，然后编译servlet)* servlet容器编译servlet源文件，生成servlet类 初始化(执行 jspInit()方法) 加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法 执行阶段（执行 _jspService(HttpServletRequest request,HttpServletResponse response) 方法） 调用与JSP对应的servlet实例的服务方法 销毁阶段（执行jspDestroy()方法 ） 调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例 1编译阶段 --&gt; jspInit() --&gt; _jspServcie() --&gt; jspDestroy() jsp获取绝对路径​ 代码” ${pageContext.request.contextPath}”的作用是取出部署的应用程序名，这样不管如何部署，所用路径都是正确的 1234&lt;!--使用绝对路径的方式引入CSS文件--&gt;2 &lt;link rel=&quot;stylesheet&quot; href=&quot;${pageContext.request.contextPath}/css/xxx.css&quot; type=&quot;text/css&quot;/&gt;3 &lt;!--使用绝对路径的方式引入JavaScript脚本--&gt;4 &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath}/js/xxx.js&quot;&gt;&lt;/script&gt; 使用&lt;%=request.getContextPath()%&gt;和使用${pageContext.request.contextPath}达到同样的效果 静态包含与动态包含&lt;%@include file=”name.jsp”%&gt; include指令是静态包含。静态包含的意思就是：把文件的代码内容都包含进来，再编译！ &lt;%jsp:include page=”name.jsp”%&gt; jsp行为包含文件就是先编译被包含的页面，再将页面的结果写入到包含的页面中 动态包含可以向被包含的页面传递参数（用处不大），并且是分别处理包含页面的（将被包含页面编译后得出的结果再写进包含页面）【如果有相同名称的参数，使用静态包含就会报错！】！ 防止表单重复提交 利用javascript防止表单重复提交 123456789101112131415&lt;form onsubmit=&quot;return dosubmit()&quot;&gt; 这是表单内容&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var isCommitted = false;//表单是否已经提交标识，默认为false 8 function dosubmit(){ 9 if(isCommitted==false){10 isCommitted = true;//提交表单后，将表单是否已经提交标识设置为true11 return true;//返回true让表单正常提交12 }else{13 return false;//返回false那么表单将不提交14 }15 }&lt;/script&gt; 还有一种方法是，当表单提交之后，设置提交按钮不可用 12345678function dosubmit(){2 //获取表单提交按钮3 var btnSubmit = document.getElementById(&quot;submit&quot;);4 //将表单提交按钮设置为不可用，这样就可以避免用户再次点击提交按钮5 btnSubmit.disabled= &quot;disabled&quot;;6 //返回true让表单可以正常提交7 return true;8 }","link":"/2019/07/08/JSP%E7%AC%94%E8%AE%B0/"},{"title":"linux基础服务搭建","text":"1234567891011121314151617# 基础环境CentOS7# 网络工具 （虚拟机初始安装的时候没有这个，需要安装）yum search ifconfigyum install net-tools.x86_64# 然后才可以使用 ifconfig （网卡）# 安装远程同步工具yum install -y rsyncyum install -y libnuma.so.1 numactl # 创建用户 groupadd wwwuseradd www -s /sbin/nologin -M -g www 多实例MySql(5.6.13 linux-Generic)123456789101112131415161718192021222324# 安装依赖yum install libaio# mysql下载地址https://downloads.mysql.com/archives/community/# 将下载的文件上传到 /usr/local/src/ 目录下mysql-5.6.13-linux-glibc2.5-x86_64.tar.gz# 不需要卸载自带的mariadb#创建用户和用户组groupadd mysqluseradd mysql -s /sbin/nologin -M -g mysql# 解压安装包（将安装包解压到/usr/local/mysql56/ 目录下）tar -zxvf mysql-5.6.13-linux-glibc2.5-x86_64.tar.gz -C /usr/local# 重新命名cd /usr/local/mv mysql-5.6.13-linux-glibc2.5-x86_64/ mysql56# 建立一个软连接ln -s /usr/local/mysql56 /usr/local/mysql 安装 Mongodb（3.6.12） (使用tar包方式)12345678910111213# 去官网地址https://www.mongodb.com/download-center/community/releases/archive# 选择3.6.12版本下载https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.12.tgz# 上传到/usr/local/src/ 目录# 执行解压命令 (一下合成一步)tar -xvzf mongodb-linux-x86_64-rhel70-3.6.12.tgz -C /usr/local/# 重新命名cd /usr/local/mv mongodb-linux-x86_64-rhel70-3.6.12 mongodb-3.6.12 安装Nginx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 查看nginx的configure/usr/local/nginx/sbin/nginx -V# 输出的内容为nginx version: nginx/1.17.9built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabled # 支持一个服务器使用多个域名证书的TLS扩展，支持用户配置多个域名证书# 支持单IP多域名SSL证书需要OpenSSL支持configure arguments: --user=www # 指定Nginx woker进程运行时所属的用户 --group=www # 指定Nginx woker进程运行时所属的组 --prefix=/usr/local/nginx # Nginx安装部署后的根目录，默认为/usr/local/nginx # 安装http stub_status模块。该模块可以让运行中的Nginx提供性能统计页面，获取相关的并发链接 --with-http_stub_status_module # 安装http ssl 模块。该模块使Nginx支持SSL协议，提供HTTPS服务。注意：该模块依赖openssl --with-http_ssl_module # 安装http realip模块。该模块可以从客户端请求的header信息（如X-Real-IP或者X-Forwarder-For)获取真正客户端的IP地址 --with-http_realip_module # 安装http image_filter模块。这个模块将符合配置的图片实时压缩为指定大小的缩略图再发送给用户，目前支持JPEG、PNG、GIF格式。注意：该模块依赖libgb库 --with-http_image_filter_module # 用来集成Google的高性能工具集(Google Performance tools 简称gperftools),这个工具集可以提供更好的内存和CPU性能分析。需要安装依赖 gperftools-libs gperftools-devel --with-google_perftools_module --with-stream # 开启TCP/IP代理模块 --with-stream_ssl_module# 安装前的准备# 如果指定用户和用户组需要提前创建，如WWW用户# 依赖包的安装yum -y install gcc gcc-c++ autoconf automake libtool make cmakeyum -y install zlib zlib-devel openssl openssl-devel pcre-devel gd-devel google-perftools google-perftools-devel# 有些参数设置需要的依赖包 (需要安装依赖才能configure成功)# gd-devel (--with-http_image_filter_module 需要的依赖)# google-perftools google-perftools-devel (--with-google_perftools_module 需要的依赖)# 从官网下载nginx 稳定版本 并上传到服务器 /usr/local/srchttps://nginx.org/en/download.html# 解压tar -zxvf nginx-1.26.0.tar.gz# 进入nginx-1.26.0目录并执行 (编译配置、编译、安装)./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_realip_module --with-http_image_filter_module --with-google_perftools_module --with-stream --with-stream_ssl_module# 编译make# 安装make install# 查看安装后的程序版本/usr/local/nginx/sbin/nginx -v# 如果修改nginx配置,验证配置是否合法/usr/local/nginx/sbin/nginx -t# 启动nginx/usr/local/nginx/sbin/nginx# 重启nginx/usr/local/nginx/sbin/nginx -s reload# 停止nginx/usr/local/nginx/sbin/nginx -s quit/usr/local/nginx/sbin/nginx -s stop# curl 访问localhost测试curl localhost# 对外访问需要开放端口（按需开放）firewall-cmd --add-port=80/tcp --permanent firewall-cmd --add-port=443/tcp --permanent firewall-cmd --reload #重载防火墙配置 安装php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 查看php的configure (以下为配置路径文件)/usr/local/php7.3.10/bin/php-config# 安装前的准备# 如果指定用户和用户组需要提前创建，如WWW用户 (configure会用到)# 从官网上下载https://www.php.net/releases/ # 选择7.3.10版本# 下载链接https://www.php.net/distributions/php-7.3.10.tar.gz# 安装依赖库yum -y install libxml2 libxml2-devel openssl openssl-devel curl-devel libjpeg-devel libpng-devel freetype-devel libmcrypt-devel bzip2-devel readline-devel # 大部分依赖包(此项不执行) yum install -y wget gcc gcc-c++ autoconf libjpeg libjpeg-devel perl perl* perl-CPAN libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers png jpeg autoconf gcc cmake make gcc-c++ gcc ladp ldap* ncurses ncurses-devel zlib zlib-devel zlib-static pcre pcre-devel pcre-static openssl openssl-devel perl libtoolt openldap-devel libxml2-devel ntpdate cmake gd* gd2 ImageMagick-devel jpeg jpeg* pcre-dev* fontconfig libpng libxml2 zip unzip gzip # 上传源码安装包到/usr/local/src/目录,并解压tar -zxvf php-7.3.10.tar.gz cd php-7.3.10# 源码编译、安装./configure --prefix=/usr/local/php7.3.10 --with-config-file-path=/usr/local/php7.3.10/etc/ --enable-fpm --enable-cli --enable-mbstring --enable-soap --enable-opcache --enable-pcntl --enable-shmop --enable-sysvmsg --enable-sysvsem --enable-sysvshm --enable-sockets --enable-zip --with-bz2 --with-readline --disable-fileinfo --disable-rpath --with-mysqli --with-pdo-mysql --with-iconv-dir --with-fpm-user=www --with-fpm-group=www --with-mhash --with-gd --with-jpeg-dir --with-png-dir --with-freetype-dir --with-zlib --enable-simplexml --with-libxml-dir --with-openssl --with-curl --enable-maintainer-zts# 这里configure报错，看下面 configure报错解决# 编译make# 对编译结果测试make test# 安装make install# 查看安装成功后的版本信息/usr/local/php7.3.10/bin/php -v# 修改配置cp /usr/local/src/php-7.3.10/php.ini-production /usr/local/php7.3.10/etc/php.ini修改php.ini文件display_errors = Off 修改为 display_errors = on# 因为后续中央服需要mongodb的支持，所以这里需要添加响应的扩展# 具体操作看以下php扩展文件的最后面加上以下代码：extension=redis.soextension=fileinfo.soextension=mongodb.so;extension=sockets.so;extension=openssl.so# 启用php-fpm服务cd /usr/local/php7.3.10/etccp php-fpm.conf.default php-fpm.confcp php-fpm.d/www.conf.default php-fpm.d/www.conf # 基本这个配置不用改 注意user与group为www 安装php的时候就已指定#启动php-fpm/usr/local/php7.3.10/sbin/php-fpmhttps://blog.csdn.net/ziqibit/article/details/129562734 configure报错解决123456789101112131415161718192021222324252627282930313233# ./configure会报错 (如果安装yum install libzip-devel -y)# configure: error: Please reinstall the libzip distribution# checking for libzip... configure: error: system libzip must be upgraded to version &gt;= 0.11# 如果用yum安装libzip-devel的话，安装的版本时0.10，版本达不到要求，所以需要卸载libzip后手动安装新版本# 1、移除旧版本yum remove libzip libzip-devel# 2、到https://libzip.org/news/ 下载1.5.2版本https://libzip.org/download/libzip-1.5.2.tar.gz# 3、解压tar -zxvf libzip-1.5.2.tar.gz# cd libzip-1.5.2# mkdir build# cd build# cmake .. (#注意：cmake后面有两个小数点, 有可能这一步会报cmake版本过低，以下有升级的方法)]# make -j4# make test# make install# 4、执行完上面后，configure还是会报错# configure: error: off_t undefined; check your library configuration#在/etc/ld.so.conf.d/路劲下创建usr_local_lib.conf 文件，并添加以下内容/usr/local/lib/usr/local/lib64/usr/lib/usr/lib64# 5、保存,让修改的文件生效ldconfig -v# 改完后configure还是报错，参考https://blog.csdn.net/weixin_43493122/article/details/96647432 Cmake版本太低了（升级Cmake）1234567891011121314151617181920212223# 报错 CMake 3.0.2 or higher is required. You are running version 2.8.12.2#升级Cmake#1、移除旧版本yum remove cmake -y#2、从官网上下载https://cmake.org/files/v3.17/ (选择3.17.5版本)https://cmake.org/files/v3.17/cmake-3.17.5-Linux-x86_64.tar.gz#上传到/usr/local/src目录中#3、进行一个解压：tar -zxvf cmake-3.17.5-Linux-x86_64.tar.gz#4、增加环境变量vim /etc/profile#在文件末尾添加以下代码 并保存：export PATH=$PATH:/usr/local/src/cmake-3.17.5-Linux-x86_64/bin#使修改的文件生效：source /etc/profile#5、验证echo $PATHcmake --version php安装扩展1234567891011121314151617181920212223242526# cd /usr/local/src/wget http://pecl.php.net/get/mongodb-1.5.2.tgz# 解压tar -zxvf mongodb-1.5.2.tgz# 切换目录 cd mongodb-1.5.2# 执行 （以下就是php的安装目录)/usr/local/php7.3.10/bin/phpize./configure --with-php-config=/usr/local/php7.3.10/bin/php-configmake &amp;&amp; make install# 安装成功后，会有类似以下安装目录信息输出：#Installing shared extensions: /usr/local/php7.3.10/lib/php/extensions/no-debug-zts-20180731# 修改配置vim /usr/local/php7.3.10/etc/php.ini# 在文档末尾加入extension-mongodb.so#然后重启php-fpm 安装Redis123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 下载安装包：(下载至/usr/local/src/ 目录下)wget http://download.redis.io/releases/redis-7.0.11.tar.gztar xzf redis-7.0.11.tar.gz -C /usr/local/#mv redis-7.0.11 ../ # 移动解压文件到上一层，也就是/usr/local/目录下cd redis-7.0.11make PREFIX=/usr/local/redis-7.0.11/ -j4 install# 创建目录 (中央服依赖这个)mkdir /data/redis/33379/{conf,data,logs} -p# 配置cp -a /usr/local/redis-7.0.11/redis.conf /data/redis/33379/conf/# 修改/data/redis/33379/conf/redis.conf配置---- 33379 ----bind 127.0.0.1protected-mode yes #开启保护模式port 33379 #端口pidfile /var/run/redis_33379.pid #进程idlogfile /data/redis/33379/logs/redis-server.log #日志dir /data/redis/33379/data/ #数据目录repl-diskless-sync noappendonly yes #开启持久化requirepass zusI9fuCMI5eHP2X #设置密码 rename-command FLUSHALL &quot;&quot;rename-command CONFIG &quot;&quot;rename-command EVAL &quot;&quot;# 修改/usr/local/redis-7.0.11/redis.conf配置 (应该用不到这个配置启动redis的,先不做处理)-------/usr/local/redis-7.0.11/redis.confbind 0.0.0.0dir /data/redis/ #数据目录appendonly yes# 测试（在/root/目录下创建脚本start-redis.sh)#!/bin/bash/usr/local/redis-7.0.11/bin/redis-server /data/redis/33379/conf/redis.conf#启动redissh /root/start-redis.sh#连接（因为上面设置了密码、所以也需要密码连接）/usr/local/redis-7.0.11/bin/redis-cli -h 127.0.0.1 -p 33379 -a zusI9fuCMI5eHP2X ping# 返回pong则为成功 安装Erlang12345678910111213# 从官网上下载erlnag25https://github.com/erlang/otp/releases/download/OTP-25.2.1/otp_src_25.2.1.tar.gz# 安装依赖yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel# 上传文件到/usr/local/src/目录下 并解压tar -zxvf otp_src_25.1.2.tar.gz# 编译cd otp_str_25.1.2./configure --prefix=/usr/local/erlang25make -j2 &amp;&amp; make install 12345678# centos7 安装使用rz/sz命令yum install -y lrzsz# 创建软链接ln -s [源文件] [软链接文件]ln -s /usr/lib64/libtcmalloc.so /usr/local/lib/libtcmalloc.so# 创建的软链接文件为/usr/local/lib/libtcmalloc.so 12需要开放的端口：80 // nginx","link":"/2024/05/11/Linux%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"},{"title":"Linux服务器运行环境配置","text":"一台云服务器需要搭建的运行环境，包括JDK、MySQL、Tomcat、Nginx等，该服务器（CentOS7）用于部署JavaEE项目 一、JDK安装卸载自带的openJDK​ 因为centos有自带的jdk，所以在安装自己的JDK时需要卸载自带的openJDK 使用rpm -qa | grep java命令查看系统中是存在有java 使用rpm -e –nodeps 相关应用名称来进行卸载 12345678[root@localhost ~]# rpm -qa | grep javajava-1.8.0-openjdk-headless-1.8.0.161-2.b14.el7.x86_64tzdata-java-2018c-1.el7.noarchpython-javapackages-3.4.1-11.el7.noarchjavapackages-tools-3.4.1-11.el7.noarchjava-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64[root@localhost ~]# rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.161-2.b14.el7.x86_64[root@localhost ~]# rpm -e --nodeps java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64 下载并安装JDK 下载ORAClE所提供的JDK,传送门可根据自己的系统来进行选择相应的版本，我这选择的是jdk-8u221-linux-x64.tar.gz 从本地上传文件到服务器，需要安装Irzsz: yum -y install lrzsz (注：参数-y中”y”的意思是：当安装过程提示选择全部为”yes”) rz中的r意为received（接收），输入rz时、意为服务器接收文件，既将文件从本地上传到服务器。sz中的s意为send（发送），输入sz时、意为服务器要发送文件，既从服务器发送文件到本地，或是说本地从服务器上下载文件。注：不论是send还是received，动作都是在服务器上发起的。 将文件上传到***/usr/java目录下，然后使用tar -zxvf jdk-8u221-linux-x64.tar.gz***进行解压 修改profile配置文件使用vi /etc/profile打开，并加入以下内容（注：传送门不熟悉vi可以先去学习以下基本操作） 123export JAVA_HOME=/usr/java/jdk1.8.0_221(这个根据你解压之后的名称来定)export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 保存退出之后需要运行source /etc/profile使配置生效 最后执行java -version验证是否安装成功 123java version &quot;1.8.0_221&quot;Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 二、MySQL安装卸载之前安装的mysql 使用以下命令查看当前安装mysql的情况，看是否有安装mysql 1rpm -qa | grep -i mysql 停止mysql服务，删除之前安装的mysql 1rpm -e --nodeps mysql(mysql表示为相关的应用名称) 查找之前老版本mysql的目录、并且删除老版本的文件和库 12345678find / -name mysql删除对应的mysql目录rm -rf /var/lib/mysql(这个是由上述命令查询出来的)...还要手动删除/etc/my.cnf文件rm -rf /etc/my.cnf 再次验证机器是否由安装mysql 1rpm -qa | grep -i mysql 安装mysql123wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-server 权限设置： 1chown mysql:mysql -R /var/lib/mysql 初始化MySQL: 1234mysqld --initialize如果报 Fatal error: Please read &quot;Security&quot; section of the manual to find out how to run mysqld as root!错误信息则在/etc/my.cnf中添加一个用户，比如user=mysql那么在启动的时候就需要：mysqld --initialize --user=mysql来初始化 启动MySQL: 1systemctl start mysqld 查看MySQL运行状态： 1systemctl status mysqld 验证MySQL是否安装123[root@localhost ~]# mysqladmin --version如果出现以下内容则证明安装成功，否则则为失败mysqladmin Ver 8.42 Distrib 5.6.45, for Linux on x86_64 使用MySQL Client(Mysql客户端)执行简单的SQL命令123[root@localhost ~]# mysql就会出现mysql&gt; 这里输入平常的sql命令即可 为root用户添加密码123[root@localhost ~]# mysqladmin -u root password &quot;新密码&quot;;那么就可以通过以下命令来连接Mysql服务器[root@localhost ~]# mysql -u root -p 三、Tomcat安装 需要先下载tomcat,传送门，我下载的是apache-tomcat-9.0.24.tar.gz 将这个文件上传到/usr/local/tomcat里面进行解压 启动tomcat 1234切换到以下目录cd /usr/local/tomcat/apache-tomcat-9.0.24/bin执行 ./startup.sh 可以通过ip addr查看linux的ip地址，然后在本机上输入*** ip地址：8080 *** 四、nginx安装需要安装几个必备的库 123yum install gcc-c++ //安装gcc环境yum install -y pcre pcre-develyum install -y openssl openssl-devel 安装上传本地的压缩包到/usr/local目录进行解压，我使用的是nginx-1.12.2.tar.gz,可以到传送门下载 123456789解压：tar -zxvf nginx-1.12.2.tar.gz创建Makefile文件：[root@localhost ~]# cd nginx-1.12.2[root@localhost nginx-1.12.2]# ./configure编译：[root@localhost nginx-1.12.2]# make安装：[root@localhost nginx-1.12.2]# make install Nginx启动与访问编译安装的Nginx其实默认被安装在CentOS7系统的***/usr/local/nginx***目录 123启动Nginx(到/usr/local/nginx目录下)[root@localhost nginx]# cd sbin[root@localhost sbin]# ./nginx 在本地输入服务器的地址 即可访问到Nginx欢迎界面，可以通过 ip addr获取到地址 如果访问不到则关闭CentOS7的防火墙，开放80端口 123[root@localhost sbin]# systemctl stop firewalld.service #停止firewall[root@localhost sbin]# systemctl disable firewalld.service #禁止firewall开机启动[root@localhost sbin]# firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running） Nginx的基本操作123456789101112查看Nginx进程：[root@localhost sbin]# ps aux|grep nginx关闭Nginx:[root@localhost sbin]# ./nginx -s stop或：[root@localhost sbin]# ./nginx -s quit重启Nginx:[root@localhost sbin]# ./nginx -s reload检查Nginx配置文件是否正确：[root@localhost sbin]# ./nginx -t","link":"/2019/09/07/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"MySQL数据库","text":"数据库的范式​ 我们常见的也就三范式： ​ 一个数据库设计如果符合第二范式（2NF），一定也符合第一范式(1NF)。如果符合第三范式(3NF)，一定也符合第二范式(2NF)。 ​ 那么下面我们就来了解什么叫做数据库的范式吧~ 1NF：属性不可再分（强调的是列的原子性，即列不能够再分成其他几列） 2NF：属性完全依赖于主键（表中必须要有一个主键，表中的其他列（除主键列外）必须完全依赖于主键，而不能只依赖于主键的部分） 3NF : 属性不依赖于其他非主属性（消除传递依赖，确保每列都和主键列直接相关，而不是间接相关） 数据库ACID 原子性 原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。 一致性 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。 隔离性 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复 并发一致性问题 丢失修改 T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 脏读 （针对未提交数据）脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 解决方法：把数据库的事务隔离级别调整到 READ_COMMITTED 不可重复读 同时操作，事务1分别读取事务2操作时和提交后的数据，读取的记录内容不一致。不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 解决方法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。把数据库的事务隔离级别调整到REPEATABLE_READ 幻读 事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 （和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致） 解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题。把数据库的事务隔离级别调整到 SERIALIZABLE_READ mysql事务 事务例子：A向B转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来一样【A账户的钱没变，B账户的钱也没变】 ​ 如果没有添加事务，当A的钱减少的时候出现异常，而B并没有接受到A的转账 ​ 解决的方法： 1234567891011121314151617181920try{ //开启事务，对数据的操作就不会立即生效 connection.setAutoCommit(false); ...a执行减操作 ....出现问题 int a = 10/0; ...b执行加操作 //如果执行到这里，没有抛出异常，就提交数据 connection.commit(); //关闭事务，设置回原始的状态 connection.setAutoCommit(true); }catch(SQLException e){ try{ //如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】 connection.rollback(); //关闭事务，设置回原来的状态 connection.setAutoCommit(true); }catch(SQLException e1){ e1.printStackTrace(); } } 注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的 事务的隔离级别 数据库定义了4个隔离级别： Serializable（串行化）【可避免脏读，不可重复读，虚读】 Repeatable read（可重复读）【可避免脏读，不可重复读】 Read committed（读已提交）【可避免脏读】 Read uncommitted（读未提交）【级别最低，什么都避免不了】 分别对应 TRANSACTION_SERIALIZABLE TRANSACTION_REPEATABLE_READ TRANSACTION_READ_COMMITTED TRANSACTION_READ_UNCOMMITTED 本文参考https://frank-lam.github.io/fullstack-tutorial/#/MySQL","link":"/2019/08/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"Servlet笔记","text":"http：http请求：一个完整http请求应该包含三个部分： 请求行【描述客户端的请求方式、请求的资源名称，以及使用的HTTP协议版本号】 多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】 一个空行 http响应：一个完整的HTTP响应应该包含四个部分: 一个状态行【用于描述服务器对请求的处理结果。】 多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】 一个空行 实体内容【服务器向客户端回送的数据】 何为ServletServlet是sun公司提供的一门用于开发动态web资源的技术 用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤： 1. 编写一个Java类，实现servlet接口。 2. 把开发好的Java类部署到web服务器中。 Servlet的运行过程Servlet程序室友Web服务器调用，Web服务器接受到客户端的Servelt访问请求后： Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步。 2. 装载并创建该Servlet的一个实例对象。 3. 调用Servlet实例对象的init()方法。 4. 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 5. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 Servlet生命周期： 访问地址 –&gt; WEB-INF –&gt; web.xml –&gt; –&gt; 执行servlet 生命周期： init()(第一次访问servlet才会调用) service() destory()（关闭服务器则调用该方法或长时间不用tomcat自动销毁） 1231.被创建，执行且只执行一次init方法2.提供服务，执行service方法，执行多次3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。 注意：只要有首次访问Servlet才创建目标 Servlet调用图 一个Servlet的创建例子1234567891011121314151617181920212223public class ServletDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.01 Transitional//EN\\&quot;&gt;&quot;); out.println(&quot;&lt;HTML&gt;&quot;); out.println(&quot; &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;); out.println(&quot; &lt;BODY&gt;&quot;); out.print(&quot;Hello World!!!&quot;); out.println(&quot; &lt;/BODY&gt;&quot;); out.println(&quot;&lt;/HTML&gt;&quot;); out.flush(); out.close(); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } web.xml需要配置上servlet的映射 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.heclam.ServletDemo&lt;/servlet-class&gt;&lt;!--这里写类的全限定名--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!--这里需要与上面Servlet-name一致 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!--这里是要输入什么才能访问到ServletDemo的映射--&gt; &lt;url-pattern&gt;/ServletDemo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 注意：&lt;servlet-mapping&gt;可以设置多个，这个我们就有多个映射路径可以访问到ServletDemo了 用servletContext实现请求转发1234567891011121314151617public class ServletDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取ServletContext对象 ServletContext context = this.getServletContext(); //获取请求转发对象 RequestDispatcher rd = context.getRequestDispatcher(&quot;/ServletDemo2&quot;); //调用forward方法实现请求转发 rd.forward(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... } } 转发（forward）和重定向（redirect）:​ 转发为在服务器里面操作，跳转到另一个servlet,它的地址栏没有改变，可以获取原来的数据，因为这是同一个request、response的http ​ 重定向：浏览器发送请求给服务器，服务器让浏览器去找其他的服务器于是浏览器又发了一条请求给其他路径的服务器，请求地址栏发生了改变（如果在地址栏里面带参数的话，是可以在服务器获取的）","link":"/2019/07/08/Servlet%E7%AC%94%E8%AE%B0/"},{"title":"Session笔记","text":"何为Session在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器中，这就是Session。 Session与Cookie的区别 Cookie是把用户的数据写给用户的浏览器 Session技术把用户的数据写到用户独占的Session中 Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象 Cookie保存在浏览器中，Session保存在服务器中 有了Cookie为何还要使用Session呢Session比Cookie使用方便，Session可以解决Cookie解决不了的事情，比如：Session可以存储对象而Cookie只能存储字符串。 Session的实现原理服务器创建session出来后，会把session的id号，以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务 SessionAPI 方法 描述 long getCreationTime() 获取Session被创建时间 String getId() 获取SessionId long getLastAccessedTime() 返回Session最后活跃的时间 ServletContext getServletContext() 获取ServletContext对象 void setMaxInactiveInterval(int var) 设置Session超时时间 int getMaxInactiveInterval() 获取Session超时时间 Object getAttribute(String var) 获取Session属性 Enumeration getAttributeNames() 获取Session所有的属性名 void setAttribute(String var1, Object var2) 设置Session属性 void removeAttribute(String var) 移除Session属性 void invalidate() 销毁该Session boolean isNew(); 该Session是否为新的 一个Session的例子1234567891011121314151617181920212223242526public class SessionDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setCharacterEncoding(&quot;UTF=8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); //使用request对象的getSession()获取session，如果session不存在则创建一个 HttpSession session = request.getSession(); //将数据存储到session中 session.setAttribute(&quot;data&quot;, &quot;heclam&quot;); //获取session的Id String sessionId = session.getId(); //判断session是不是新创建的 if (session.isNew()) { response.getWriter().print(&quot;session创建成功，session的id是：&quot;+sessionId); }else { response.getWriter().print(&quot;服务器已经存在该session了，session的id是：&quot;+sessionId); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } Session也是一个域对象，Session作为一种记录浏览器状态的机制，只要Session对象没有被销毁，Servlet之间就可以通过Session对象实现通信 1234//使用request对象的getSession()获取session，如果session不存在则创建一个 HttpSession session = request.getSession();//获取存入Session的属性 String val = session.getAttribute(&quot;data&quot;);","link":"/2019/07/08/Session%E7%AC%94%E8%AE%B0/"},{"title":"Spring事务管理","text":"事务的四个特性（ACID）： 原子性：原子性是指事务是一个不可分割的工作单位，事务里面的操作要么都发生，要么都不发生，如果有一个操作失败，事务将回滚 一致性：一致性指事务前后数据的完整性必须保持一致（事务执行的前后都是合法的数据状态，不会违背任何的数据完整性） 隔离性：隔离性指多个用户并发访问数据库时，一个用户的事务不被其他用户的事务所干扰，多个并发事务之前要相互隔离 持久性：持久性是指一个事务一旦被提交，那么数据就一定会被写入到数据库中并持久储存起来（事务被提交之后无法再回滚） 事务的属性传播行为（propagation）：传播行为定义了客户端与被调方法见的事务边界 PROPAGATION_REQUIRED：默认传播行为，指的是若当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务 PROPAGATION_REQUIRES_NEW：需要创建一个新的，若当前有事务，则将当前事务挂起。 PROPAGATION_SUPPORTS： 当前存在事务，就在事务中运行；当前不存在事务，则不在事务中运行。 PROPAGATION_NOT_SUPPORTED: 不运行在事务中，当前有事务，则挂掉当前事务。 PROPAGATION_NEVER：不运行在事务中，如果当前有事务，则抛出异常。 PROPAGATION_MANDARORY: 必须运行在事务中，如果当前方法没有事务，则抛出异常。 PROPAGATION_NESTED: 当前存在事务，则创建一个事务作为当前事务的嵌套事务运行，如果当前没有事务，则创建一个新的事务。 **隔离级别（isolation）:**指若干个并发事务之间的隔离程度 默认（DEFAULT） READ_UNCOMMITTED：读未提交，一个事务可以读取到另一个事务未提交的数据。（脏读，不可重复读，幻读）。 READ_COMMITTED：读已提交，一个事务只能读取另一个事务已经提交的数据。（不可重复读，幻读）。 REPEATABLE_READ：可重复读一个事务在整个过程中多次重复执行某个查询，每次返回的结果都相同。（幻读） SERIALIZABLE：序列化所有事务依次逐个执行，这样事务之间不可能存在干扰。 隔离引发的一些问题： 脏读：一个事务读取了另一个事务改写但未提交的数据 不可重复读（侧重于修改）：一个事务执行多次的读操作，每次得到不同数据。（并发访问造成的，可能另外一个事务已经对数据进行了更改） 幻读（侧重于新增或删除）：类似不可重复读。一个事务读取时遇到另一个事务的插入，则这个事务就会读取到一些原本不存在的记录。只读：事务只读时，数据库就可以对其进行一些特定的优化。事务超时：事务运行时间过长。回滚原则：定义那些异常会导致事务回滚。（默认情况只有运行时异常才事务回滚） Spring基于XML的声明式事务 Spring的声明式事务的支持是通过Spring AOP框架来实现的 123456789101112131415161718192021222324252627282930&lt;!-- 1.加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--2.配置数据源：有两个选择 c3p0,阿里的连接池druid--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--配置链接属性--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;/bean&gt; &lt;!--3.配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;...DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--4.配置事务通知，根据方法名，指定事务的属性--&gt;&lt;!--这是需要tx和aop的命名空间--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; propagation='&quot;SUPPORTS&quot;&gt; &lt;tx:method name=&quot;transferAc&quot; protagation=&quot;REQUIRED&quot;&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--5.配置aop,将事务和切入点关联起来--&gt;&lt;aop:config&gt; &lt;aop:pointcut expresssion=&quot;execution(* com.heclam.*(...))&quot; id=&quot;txPointcut&quot;&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; &lt;tx:advice&gt;实现声明事务性策略，所有的事务配置都在这里面， isolation:指定事务的隔离级别 propagation:指定事务的传播规则 read-only:指定事务为只读 使用&lt;tx:advice&gt;声明事务，需要一个事务管理器，这里定义了一个AOP的通知，然后还需要使用&lt;aop:config&gt;定义一个通知器（advisor）,里面还需定义一个切入点 Spring基于注解的声明式事务配置123456789101112131415161718192021222324252627282930&lt;!-- 1.加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--2.配置数据源：有两个选择 c3p0,阿里的连接池druid--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!--配置链接属性--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;/bean&gt; &lt;!--3.配置事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;...DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--4.启动事务注解--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;以下的配置是在类中&lt;!--5.可以在对应的方法或类上添加Transaction注解--&gt;@Transactionpublic void transferAc(){}或者@Transactionpublic class Demo{ } 个人觉得还是基于注解的声明式事务比较简单些,不用做很多的配置","link":"/2019/08/14/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"title":"git笔记","text":"git命令的介绍：git init //将某目录变成git可以管理的仓库（在此文件夹下生成了.git文件夹） git add xxx.md //添加xxx.md文件到暂存区（从工作区–&gt;暂存区） git add . //这是添加所新建的所有文件到暂存区 git commit -m “提交注释” //一次性提交多个文件（add进来的文件），将文件提交到本地仓库（暂存区–&gt;本地仓库） git status //可以时刻知道仓库的当前状态 git diff //查看修改的内容（与提交进去的文件相比） git log //查看仓库历史记录 ，命令显示从最近到最远的提交日志 版本回退：git reset –hard 将会重置HEAD返回到另外一个commit,这个是个比较微信的动作，具有破坏性，数据因此可能会丢失，如果想找回原来的数据就使用 git reflog命令 Git中，用HEAD表示是当前的版本，上一个版本就是HEAD^,上上个版本就是HEAD^^ 123git reset --hard HEAD^ //回退到上一个版本git reset --hard HEAD~10 //回退到上10个版本 也可以指定回滚的版本号，版本号用git log查看commit id前7位 如果我们忘记回退前的版本号，git reflog 命令记录了每一次的命令操作，包含了所有版本的版本号。 撤销操作1234git checkout --file //该命令会把文件在工作区的修改全部撤销，回到最近一次git commit 或git add 时的状态。git reset HEAD file //该命令会把暂存区的修改车削掉，重新放回到工作区中git rm file //使用该命令可以删除版本库中的文件，比如执行 git rm abc.txt ,然后再执行commit操作则成功删除，误删恢复使用 git checkout --abc.txt 远程仓库首先需要拥有github的账号 创建SSH Key密钥 1ssh-keygen -t rsa -C &quot;注册github的email&quot; 然后在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，然后将id_rsa.pub里面的内容添加到github上面 在github上面创建仓库 123456789101112131415git remote add origin xxx.git //xxx.git 为仓库的地址，关联远程仓库//一般push之前先pull一下 把远程仓库的内容更新到本地仓库git push -u origin master //将本地仓库推送到远程分支上由于远程库是空的，我们第一次推送 master 分支时，加上了 `-u` 参数，Git不但会把本地的master分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以不使用 `-u`参数。git remote //列出已存在的远程分支git remote remove name //删除添加的远程库//从远程克隆仓库git clone xxx.git //xxx.git 远程仓库地址 分支管理master：默认为主分支，Head 指向哪个分支，则表明那个分支为当前分支 创建分支 123456789101112131415git branch abc //创建abc分支git checkout abc //切换至abc分支git checkout -b abc //（这条命令与上面两条的命令效果一样）创建了一个abc分支并且切换到了abc分支中git branch //查看当前分支git merge name //合并指定分支与当前分支，name为分支的名称（比如master分支需要合并abc分支的内容，则在master分支下执行 git merge abc）合并分支的时候，有时候需要解决冲突（比如abc分支提交了一个内容，master分支也提交了一个内容就造成了冲突）再合并git merge -no-ff -m &quot;...&quot; 分支名 // 禁用git合并时默认的fast-forward模式，生成新的commit加入分支信息git branch -d 分支名 //删除分支 工作现场存储1234567git stash //将当前工作现场储藏起来，等以后恢复现场后继续工作git stash list //查看储藏的工作现场git stash apply //恢复储藏的工作现场,stash内容并不删除，你需要用git stash drop来删除git stash pop //恢复的同事把stash内容也删除了 多人协作1234567git checkout -b abc origin/abc //从远程库克隆到本地仓库，克隆对应的分支，比如这里为abc分支1.用git push origin abc（分支名） 推送自己的修改2.如果失败，因为远程分支比本地分支内容新，需要先git pull 合并一下3.如果有冲突则解决冲突后在提交4.使用git push origin abc(分支名) 推送到远程库如果 git pull 提示 “no tracking information”，则需要创建本地分支和远程分支的关联git branch --set-upstream abc(分支名) origin/abc(分支名)。 标签管理123456789101112git tag tagName //打标签例子：git tag v0.1忘记在某次commit时打标签，可以使用以下的方式git tag v1.0 2893423 //将commit id为2893423的提交打上v1.0标签git tag //查看标签git show &lt;tagname&gt; //查看标签信息git tag -a v2.0 -m &quot;记录信息&quot; 23498222（commit id）//创建带有说明的标签，-a 指定标签名，-m指定说明git tag -d tagName //删除指定标签因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt;，使用 git push origin --tags 一次性推送全部尚未推送到远程的本地标签。git tag -d tagname &amp; git push origin :refs/tags/tagname:删除已推送到远程库的标签，先从本地删除，再从远程删除","link":"/2019/06/15/git%E7%AC%94%E8%AE%B0/"},{"title":"hexo+github搭建我的博客","text":"经过两天的搭建终于搭成了 在多终端操作博客的搭建中遇到的坑比较多hexo文档 搭建完基本的博客时，实现多终端操作博客需要注意的点： ​ 1.本地博客的配置文件(_config.yml)中的deply: branch:master(必须为主分支，因为master就是用来部署上去的 hexo g -d） ​ 2.需要在github上新建一个分支（比如 hexo）,这时候master分支与hexo分支的内容是一样的（为什么需要新建分支呢？ hexo用来存放原来博客的配置文件，这样才能实现多终端的操作而master分支用来存放静态文件的展示） ​ 3.在本地的博客目录中，找到主题（theme）目录下的主题，如果是clone下来的主题必须把里面的.git(一般是隐藏的，要开启隐藏文件可见)删除，不然待会的push到github会出错（因为一个仓库只能有一个.git文件） ​ 4.在本地的博客目录中找到 .gitignore文件，里面添加（public/ 、 .deploy*/ 、_config.yml）一行一个，public文件里面是hexo -g（根据source目录生成的）生成的文件所以不必要添加，.deploy_git是hexo默认的.git配置文件夹，不需要同步， _config.yml是一个博客的配置文件也不应该上传（但我嫌麻烦就上传了 ） ​ 5.到这一步就是在本地目录打开终端（cmd）,再初始化仓库，重新对代码进行版本控制 ​ git init ​ git remote add origin ​ //为远程仓库的地址，origin是本地分支,remote add操作会将本地仓库映射到云端 将博客源文件上传到hexo分支 ​ git add . ​ git commit -m “更新内容” ​ git push origin hexo (如果这一步有错，可以先执行git push -u origin hexo -f 但建议不要这么做，因为有数据丢失)，出现这个问题就是本地分支与hexo分支内容不同，可以先 pull 然后再push, 如果push出现错误，可以在本地新建一个分支hexo对应github上的hexo分支（这时候master与hexo分支的内容是一致的），这是后push就可以，我也不知道为什么（苦笑） 在其他电脑的操作可以现在其他电脑生成ssh密钥，这样就不用频繁（提交的时候）输入账号密码了 生成新的ssh key 打开终端输入一下命令： ssh-keygen -t rsa -c “注册时的邮箱” 输入命令后, 然后连续回车, 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件 将id_rsa.pub这里面的内容复制 将ssh key添加到Github中 打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： title随便起，key填入刚刚复制的内容 将博客项目克隆下来 git clone url //url表示的是项目地址 克隆下来的仓库和你在个人PC中的目录是一模一样的，所以可以在这基础上继续写博客了。但是由于.gitignore文件中过滤了node_modules\\，所以克隆下来的目录里没有node_modules\\，这是hexo所需要的组件，所以要在该目录中重新安装hexo，但不需要hexo init。 npm install hexo npm install //安装依赖 npm install hexo-deployer-git –save //安装部署插件 新建文章 hexo new article //article表示的是你的文章名称 推送到hexo分支 git add . git commit -m “新增内容” git push origin hexo 部署到master分支 hexo g -d","link":"/2019/06/14/hexo-github%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"title":"java反射机制","text":"Java反射机制是指在 运行状态中 ，对于任意一个 类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。 获取class的三种方法12345678910111213141516171819202122package com.luo.test;public class TestDemo{ public static void main(String[] args){ //第一种 Class class1 = TestDemo.class; System.out.pritnln(class1.getName（）); //第二种 TestDemo demo = new TestDemo(); Class class2 = demo.getClass(); System.out.pritnln(class2.getName（）); //第三种 Class class3 = Class.forName(&quot;com.luo.test.TestDemo&quot;);//这里面的参数为类的全量限定名 System.out.pritnln(class2.getName（）); }}执行结果为： com.luo.test.TestDemo com.luo.test.TestDemo com.luo.test.TestDemo 获取这个Class有什么作用？ 获取成员方法Method 获取成员变量Field 获取构造函数Constructor 获取成员方法单独获取某一个方法是通过Class类的以下方法获得的： 123//参数：第一个参数为方法名，后面的参数为 参数类型 比如 String.class int.class(可以看下方的例子)public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的 例如有个一类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person { private String name; private int age; private String msg=&quot;hello wrold&quot;; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person() { } private Person(String name) { this.name = name; System.out.println(name); } public void fun() { System.out.println(&quot;fun&quot;); } public void fun(String name,int age) { System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;); }}public class TestDemo{ public static void main(String[] args){ try { Class c = Class.forName(&quot;com.luo.Person&quot;); Object o = c.newInstance(); Method method = c.getMethod(&quot;fun&quot;, String.class, int.class); method.invoke(o, &quot;abc&quot;, 18); } catch (Exception e) { e.printStackTrace(); } }} 12执行结果： 我叫abc,今年18岁 获取所有的成员方法： 123456789Class c = Class.forName(&quot;com.luo.Person&quot;);//不带参数则获取全部的方法Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的或者：Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的遍历数组：for (Method method : methods) 获取成员变量单独获取某个成员变量，通过Class类的以下方法实现： 1234public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量注意：field.setAccessible(true);//如果变量的访问属性为private,需设置是否允许访问 获取全部的成员变量： 1234Field[] fields = c.getDeclaredFields();然后遍历变量数组,获得某个成员变量：for(Field field : fields) 获取构造方法获取单个构造函数（传入参数） 12345public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所有的构造器，不包括其父类的构造器public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类注意： constructor.setAccessible(true);//如果构造方法为private，需设置是否允许访问 获取该类的所有构造函数 1234Constructor[] constructors = c.getDeclaredConstructors();然后遍历：for (Constructor constructor : constructors)","link":"/2019/06/26/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"java线程","text":"进程与线程的区别 进程: 进程简单的来说就是在内存中运行的应用程序，一个进程可以启动多个线程。​ 比如在windows中一个运行( xxx.EXE文件 )就是一个进程。进程是系统运行程序的基本单位 线程: 线程是是一个比进程更小的执行单位，一个线程执行过程中可以产生多个线程。 ​ 同一个线程中的进程共用相同的地址空间，同时共享进程所拥有的内存和其他资源。 并行与并发 并行：同一时间段，多个任务都在执行（单位时间内不一定同时执行） 并发：单位时间内，多个任务同时执行 使用多线程可能带来的问题：内存泄露、上下文切换、死锁 何为死锁例子：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们有必需获取相互的资源才能完成线程，比如线程A需要获取资源1（线程B也需要获取资源2）才能完成线程操作，所才会释放，现在各自抱着其他线程所需要的资源而形成死锁。 创建多线程有两种方法 继承Thread,重写run方法 1234567891011121314public class MyThread extends Thread { @Override public void run() { for (int x = 0; x &lt; 200; x++) { System.out.println(x); } }}----调用public static void main（String [] args）{ MyThread my1 = new MyThread(); my1.start();} 实现Runnable接口，重写run方法（这个比较常用，避免java单继承的限制） 123456789101112131415161718public class MyRunnable implements Runnable { @Override public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(x); } }}----调用 public static void main(String[] args) { MyRunnable my = new MyRunnable(); Thread t1 = new Thread(my); t1.start(); } 线程有3个基本状态：执行、就绪、阻塞 sleep()和wait()的区别两者的区别在于：sleep方法没有释放锁，而wait方法释放了锁 两者都可以暂停线程的执行 wait()通常用于线程间交互/通信，sleep()通常用于用户暂停执行 wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法。sleep方法执行完成后，线程会自动苏醒。 synchronized关键字synchronized关键字解决多个线程之间访问资源的同步性，它可以保证由它休息的方法或代码块再任意时刻只有一个线程执行。 用法： 修饰实力方法：给当前对象加锁，进入同步代码块前要获取当前对象实例的锁 1public synchronized void add(){} 修饰静态方法：给当前类加锁（因为静态方法没有this），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。 1public synchronized static void add(){} 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁 1synchronized(object){ } 线程中常用的方法方法详解 public static void sleep(long mills) 当调用sleep()方法时，必须捕获异常或者向上层抛出异常。当线程休眠时间满时，并不一定会马上执行，因为此时有可能CPU正在执行其他的任务，所以调用了sleep()方法相当于线程进入了阻塞状态。 public static void yield() 调用yield()方法是为了让当前线程交出CPU权限，让CPU去执行其他线程。它和sleep()方法类似同样是不会释放锁。但是yield()不能控制具体的交出CUP的时间。并且它只能让相同优先级的线程获得CPU执行时间的机会。 调用yield()方法不会让线程进入阻塞状态，而是进入就绪状态，它只需要等待重新获取CPU的时间，这一点和sleep()方法是不一样的。 public final void join() join()方法的作用是等待线程对象销毁，如果子线程执行了这个方法，那么主线程就要等待子线程执行完毕之后才会销毁 setDaemon(boolean on),getDaemon() 用来设置是否为守护线程和判断是否为守护线程 守护线程依赖于创建他的线程，而用户线程则不需要。如果在main()方法中创建了一个守护线程，那么当main方法执行完毕之后守护线程也会关闭。而用户线程则不会，在JVM中垃圾收集器的线程就是守护线程。 有返回值得多线程​ 简单的实现有返回值得线程 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class CallableFuture { public static void main(String[] args) { //创建一个线程池 ExecutorService pool = Executors.newFixedThreadPool(3) ; //创建三个有返回值的任务 CallableTest2 c1 = new CallableTest2(&quot;线程1&quot;) ; CallableTest2 c2 = new CallableTest2(&quot;线程2&quot;) ; CallableTest2 c3 = new CallableTest2(&quot;线程3&quot;) ; Future f1 = pool.submit(c1) ; Future f2 = pool.submit(c2) ; Future f3 = pool.submit(c3) ; try { System.out.println(f1.get().toString()); System.out.println(f2.get().toString()); System.out.println(f3.get().toString()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); }finally{ pool.shutdown(); } }} 123456789101112131415 import java.util.concurrent.Callable; public class CallableTest2 implements Callable { private String name ; public CallableTest2(String name) { this.name = name; } @Overridepublic Object call() throws Exception { return name+&quot;返回了东西&quot;;} }","link":"/2019/07/07/java%E7%BA%BF%E7%A8%8B/"},{"title":"java集合总结","text":"List:(有序（存储顺序和取出顺序一致），可重复) ArrayList底层数据结构是数组。线程不安全J(如果想要ArrayList是实现同步，可以使用Collections的方法：List list = Collections.synchronizedList(new ArrayList()),就可以实现同步了) LinkedList底层数据结构是链表。线程不安全(LinkedList底层是双向链表) Vector底层数据结构是数组。线程安全 ​ #### 注：查询多用Arraylist（底层实现为数组），增删多则用LinkedList(底层实现为双向链表（双向链表方便往前遍历）) Set（元素不可重复） HashSet集合 底层数据结构是哈希表（是一个元素为链表的数组）+红黑树 TreeSet集合 底层数据结构是红黑树（是一个自平衡的二叉树） 保证元素的排序方式 LinkedHashSet集合 底层数据结构是由哈希表（是一个元素为链表的数组）+双向链表组成 HashSet 实现Set接口 不保证迭代顺序 允许元素为空 底层实际上是一个HashMap实例 非同步 初始容量非常影响迭代性能 TreeSet 实现NavigableSet接口 可以实现排序功能 有序，不允许为null 底层实际是一个TreeMap实例 非同步 LinkedHashSet 迭代是有序的 允许为空 底层实际是一个HashMap+双向链表实例（其实就是LinkedHashMap） 非同步 性能比HashSet差一点，因为要维护一个双向链表 初始容量与迭代无关，LinkedHashSet迭代的是双向链表 散列表（数组+链表） 不在意元素的顺序，能够快速的查找元素的数据 红黑树 红黑树是二叉搜索树。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) **从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点(每一条树链上的黑色节点数量（称之为“黑高”）必须相等)**。 Map Set&lt;Map.Entry&lt;k key,v value&gt; entrySet();返回的是键值对对象的集合 Set keySet(); 获取集合中所有的键的集合 Collection values(); 获取集合中所有值得集合 Map集合的特点：将键映射到值得对象，一个映射不能包含重复的键，每个键最多只能映射到一个值 Map和Collection集合的区别： ​ 1.Map集合存储元素师成对出现的，Map的键是唯一的，值是可以重复的 ​ 2.Collection集合存储元素是单独出现的，collection的儿子set是唯一的，List是可重复的 HashMap1234特点： * 无序，允许为null,非同步 * 底层由散列表（哈希表）实现 * 初始容量和装载因子对HashMap影响挺大的，设置小了不好，设置大了也不好 HashMap与Hashtable比较 从存储结构和实现来讲基本上都是相同的。Hashtable和HashMap的最大的不同是它是线程安全的，另外它不允许key和value为null。Hashtable是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换 LinkedHashMap（继承HashMap） 底层是散列表和双向链表 允许为null,不同步 插入的顺序是有序的（底层链表致使有序） 装载因子和初始容量对LinkedHashMap影响很大 TreeMap TreeMap实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，致使我们的TreeMap是有序的！ TreeMap底层是红黑树，它方法的时间复杂度不会太高 非同步，想要同步可以使用Collections来进行封装 使用Comparator或者Comparable来比较key是否相等与排序的问题 key不能为null，为null抛出NullPointException的异常 ConCurrentHashMap 底层实现是：散列表和红黑树，与hashMap是一样的 ConcurrentHashMap支持高并发的访问和更新，他的线程是安全的 检索操作不用加锁，get方法是非阻塞的 key和value都不允许为空","link":"/2019/06/29/java%E9%9B%86%E5%90%88/"},{"title":"markdown语法","text":"嗯，下面记录一下markdown的语法 1.斜体和粗体12341.*斜体* ， _斜体_2.**粗体**3.***加粗斜体***4.~~删除线~~ 2.标题1# 一级标题（前面“#”有多少个就表示为几级标题） 3.超链接 行内式 []里面写链接文字，（）里面写链接地址，（）中的“ ”可以为链接指定title属性，title属性可加可不加 12[链接文字]（链接地址 &quot;title 可加可不加&quot;）比如： [百度官网链接](http://www.baidu.com &quot;百度&quot;) 参考式 参考式链接分为两部分， [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以作为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址 1234567[Google][1][我的github][2][爱奇艺][][1]:http://www.google.com &quot;Google&quot;[2]: http://myName.github.io &quot;github&quot;[爱奇艺]：http://www.aiqiyi.com 自动连接 用&lt;&gt;包起来 1&lt;http://www.baidu.com&gt; 列表 使用*，+，-表示无序列表 123- 无序列表+ 无序列表* 无序列表 有序列表则使用数字接着一个英文句号 1231. 有序列表2. 二3. 三 引用 “&gt;”代表引用(引用的多层嵌套) 123&gt; 引用1&gt;&gt; 应用2&gt;&gt;&gt; 应用3 插入图片1![图片文字](图片地址 &quot;图片title&quot;) //图片文字和标题都可省略 表格 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐 1234id|name|age-|-|-123|abc|19456|wer|18 分割线 一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西 代码 插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入 使用六个” ` “来包括代码","link":"/2019/06/20/markdown%E8%AF%AD%E6%B3%95/"},{"title":"了解一下Redis","text":"Redis支持以下五种类型 String list set SortedSet Hash 键的过期时间 设置键的生存时间可以通过EXPIRE或者PEXPIRE 设置键的过期时间可以通过EXPIREAT或者PEXPIREAT 其实EXPIRE、PEXPIRE、EXPIREAT这三个命令都是通过PEXPIREAT命令来实现的 过期策略 过期键是保存在哈希表中了。那这些过期键到了过期的时间，就会立马被删除掉吗？？ 删除策略可以分为三种： 定时删除(对内存友好，对CPU不友好) 到时间点上就把所有过期的键删除了 惰性删除(对CPU极度友好，对内存极度不友好) 每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除 定期删除(折中) 每隔一段时间去删除过期键，限制删除的执行时长和频率。 Redis采用的是惰性删除+定期删除两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！ Redis持久化 Redis提供两种不同的持久化方法来将数据存储到硬盘里面： RDB(基于快照)，将某一时刻的所有数据保存到一个RDB文件中。 AOF(append-only-file)，当Redis服务器执行写命令的时候，将执行的写命令保存到AOF文件中。 RDB(快照持久化) 流程： 数据库状态 –保存—–》 RDB文件 数据库状态 《—-还原— RDB文件 有两个命令可以生成RDB文件： SAVE会阻塞Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止 BGSAVE创建出一个子进程，由子进程来负责创建RDB文件，服务器进程可以继续接收请求。 Redis服务器在启动的时候，如果发现有RDB文件，就会自动载入RDB文件(不需要人工干预) 服务器在载入RDB文件期间，会处于阻塞状态，直到载入工作完成。 除了手动调用SAVE或者BGSAVE命令生成RDB文件之外，我们可以使用配置的方式来定期执行 123save 900 1 #在900秒(15分钟)之后，至少有1个key发生变化，save 300 10 #在300秒(5分钟)之后，至少有10个key发生变化save 60 10000 #在60秒(1分钟)之后，至少有10000个key发生变化 AOF(文件追加) 流程： 客户端 —发送写的命令—-》服务器 —-保存被执行的写命令—–》AOF文件 AOF持久化功能的实现可以分为3个步骤： 命令追加：命令写入aof_buf缓冲区 文件写入：调用flushAppendOnlyFile函数，考虑是否要将aof_buf缓冲区写入AOF文件中 文件同步：考虑是否将内存缓冲区的数据真正写入到硬盘 主从框架 主从框架的特点 主服务器负责接受写请求 从服务器负责接收读请求 从服务器的数据由主服务器复制过去。主从服务器的数据是一致的 主从框架的好处： 读写分离(主服务器负责写，从服务器负责读) 高可用(某一台从服务器挂了，其他从服务器还能继续接收请求，不影响服务) 处理更多的并发量(每台从服务器都可以接收读请求，读QPS就上去了) 复制功能主从架构的特点之一：主服务器和从服务器的数据是一致的。 Redis服务器（主） 《———–复制——————- Redis服务器（主） 复制功能分为两个步骤 同步（sync） 将从服务器的数据库状态更新至主服务器的数据库状态 命令传播(command propagate) 主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致，让主从服务器的数据库状态重新回到一致状态。 从服务器对主服务器的同步又可以分为两种情况： 初次同步：从服务器没有复制过任何的主服务器，或者从服务器要复制的主服务器跟上次复制的主服务器不一样。 断线后同步：处于命令传播阶段的主从服务器因为网络原因中断了复制，从服务器通过自动重连重新连接主服务器，并继续复制主服务器 哨兵(Sentinal)机制​ 哨兵机制可以监控，但主服务器瘫痪了之后，可以指定一台从服务器为新的主服务器,如果旧的主服务器接上来，那么旧的主服务器成为了从服务器 缓存雪崩什么是缓存雪崩？ 如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。 这就是缓存雪崩： Redis挂掉了，请求全部走数据库。 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。 缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！ 解决方法​ 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 ​ 对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路 事发前：实现Redis的高可用（主从框架+Sentinel(哨兵)或者Redis Cluster）,尽量避免Redis挂掉这种情况发生。 事发中：万一Redis真的垮了，我们可以设置本地缓存（ehcache）+限流（hystrix）,尽量避免我们的数据库被干掉（起码能保证我们的服务还是能正常工作的） 事发后： redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。 缓存穿透什么是缓存穿透？ 比如数据库后台表的ID都是大于1的书，每次请求的ID都是负数，这会导致我们的缓存不起作用，请求全部都去找数据库了，但数据库也没有这个值，所以每次返回都是空。 缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。 这就是缓存穿透： 请求的数据在缓存大量不命中，导致请求走数据库。 缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！ 解决方法解决缓存穿透的两种方案： 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！ 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。 这种情况我们一般会将空对象设置一个较短的过期时间。","link":"/2019/08/25/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BRedis/"},{"title":"代理（Proxy）","text":"动态代理技术是整个java技术中最重要的一个技术，它是学java框架的基础，在Spring框架中广泛使用 动态代理技术就是用来产生一个对象的代理对象 代理对象存在的价值主要用于拦截对真实业务对象的访问 代理对象应该具有和目标对象（真实业务对象）相同的方法 java中的代理通过java.lang.reflect.Proxy 类提供的一个newProxyInstance方法来串讲一个对象的代理对象想要生成某一个对象的代理对象，这个代理对象也要编写一个类来生成 12345参数解析： first arg:ClassLoader loader用来指明生成代理对象使用哪个类加载器 second arg:Class&lt;?&gt;[] interfaces用来指明生成哪个对象的代理对象，通过接口指定 third arg:InvocationHandler h用来指明产生的这个dialing对象要做什么事情static Object newProxyInstance(ClassLoader loader,class&lt;?&gt;[] interfaces,InvocationHandler h) 编写生成代理对象的类在java中规定，要想产生一个对象的代理对象，那么这个对象必须要有一个接口 例子：(要想为一个类生成一个代理对象，前提是这个类必须要有一个接口，比如下面的AbcMan就有一个Person接口) 1234public interface Person{ String sing(String name); String dance(String name);} 123456789public class AbcMan implements Person{ public String sing(String name){ return &quot;sing a&quot;+name+&quot;song&quot;; } public String dance(String name){ return &quot;dance&quot;+name; }} 创建生成代理对象的代理类123456789101112131415161718192021222324252627282930public class AbcManProxy{ //设计一个类变量记住代理类要代理的目标对象 private Person abc = new AbcMan(); //设计一个方法生成代理对象 public Person getProxy(){ return (Person)Proxy.newProxyInstance(AbcManProxy.class.getClassLoader(),abc.getClass().getInterfaces(),new InvocationHandler(){ /* 参数解析： first arg:把代理对象自己传递进来 second arg:把代理对象当前调用的方法传递进来 third arg:把方法参数传递进来 */ @Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{ //如果调用的是代理对象的sing方法 if(method.getName().equals(&quot;sing&quot;)){ System.out.println(&quot;这里由代理类做一些操作sing&quot;); return method.invoke(abc,args);//代理对象调用真实目标对象的sing方法去处理用户请求 } if(method.getName().equals(&quot;dance&quot;)){ System.out.println(&quot;由代理类做一些操作dance&quot;); return method.invoke(abc,args); } return null； } })； } } 测试： 1234567891011121314151617181920public Class Test{ public static void main(String[] args){ AbcManProxy proxy = new AbcManProxy(); //获取代理对象 Person p = proxy.getProxy(); //调用代理对象的sing方法 String singstr = p.sing(&quot;aaa&quot;); System.out.println(singstr); //调用代理对象的dance方法 String dancestr = p.dance(&quot;bbb&quot;); System.out.println(dancestr); }}-----输出的结果为：这里由代理类做一些操作singsing a aaa song //目标方法执行由代理类做一些操作dancedance bbb 静态代理模式123public interface Person{ void sing();} 静态代理需要创建接口实现类和代理类，这两个类分别实现这个接口 123456public class Abc implements Person{ @Override public void sing(){ System.out.println(&quot;Abc高歌一曲&quot;); }} 12345678910111213public class ProxyAbc implements Person{ //接收实现类对象 private Person p; //通过构造方法传进来实现类对象 public ProxyAbc(Person p){ this.p = p; } @Override public void sing(){ System.out.println(&quot;代理类做的操作&quot;); this.p.sing(); }} 静态代理测试： 1234567public class Test{ public static void main(String [] args){ Person abc = new Abc(); Person proxy = new ProxyAbc(abc); proxy.sing(); }} JDK动态代理 动态代理不需要创建代理类，只需要编写一个动态处理器即可 12345678910111213141516171819202122232425262728public class JdkProxyHandler{ //用来接收实现类对象 private Object abc; //通过构造方法传进来实现类对象 public JdkProxyHandler(Person p){ super(); this.abc = p; } //为实现类对象创建一个代理对象的实例 public Object getProxyInstance(){ /* 参数解析： first arg:指定当前目标对象使用的类加载器 second arg: 指定目标对象实现的接口的类型 third arg: 指定动态处理器 */ return Proxy.newProxyInstance(abc.getClass().getClassLoader(),abc.getClass().getInterfaces(),new InvocationHandler(){ @Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{ System.out.printn(&quot;代理做一些相应的操作&quot;); Object object = method.invoke(abc,args); return obejct； } }); }} JDK动态代理测试： 1234567public class Test{ public static void main(String [] args){ Person abc = new Abc(); Person proxy = new JdkProxyHandler(abc).getProxyInstance(); proxy.sing(); }} CGLIB动态代理JDK动态代理需要实现类通过接口定义方法，那对于没有实现接口的类就使用了CGLIB动态代理来实现 1234567891011121314151617181920212223public class CglibProxyHandler implements MethodInterceptor{ //维护目标对象 private Object target; public Object getProxyInstance(final Object target){ this.target = target; // Enhancer类是CGLIB中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展 Enhancer enhancer = new Enhancer(); // 将被代理的对象设置成父类 enhancer.setSuperclass(this.target.getClass()); // 回调方法，设置拦截器 enhancer.setCallback(this); // 动态创建一个代理类 return enhancer.create(); } @Override public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;代理做一些操作&quot;); Object result = methodProxy.invokeSuper(object, args); return result; }} 使用 CGLIB 需要实现 MethodInterceptor 接口，并重写intercept 方法，在该方法中对原始要执行的方法前后做增强处理。该类的代理对象可以使用代码中的字节码增强器来获取 JDK动态代理测试： 1234567public class Test{ public static void main(String [] args){ Person abc = new Abc(); Person proxy = new CglibProxyHandler().getProxyInstance(abc); proxy.sing(); }} JDK 动态代理和 CGLIB 动态代理均是实现 Spring AOP 的基础 如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP；如果目标对象没有实现了接口，则采用 CGLIB 库，Spring 会自动在 JDK 动态代理和 CGLIB 动态代理之间转换。","link":"/2019/07/15/%E4%BB%A3%E7%90%86(Proxy)/"},{"title":"常见的设计模式","text":"单例模式 构造方法私有化 在类的内部创建实例 提供获取唯一实例的方法 单例模式分为懒汉式和饿汉式 懒汉式(要用的时候才创建) 12345678910111213141516171819public class Demo { // 1.将构造函数私有化，不可以通过new的方式来创建对象 private Demo(){} // 2.先不创建对象，等用到的时候再创建 private static Demo demo = null; // 3.调用到这个方法了，证明是要被用到的了 public static Demo getInstance() { // 4. 如果这个对象引用为null，我们就创建并返回出去 if (demo == null) { demo = new Demo(); } return demo; }} 懒汉式单例模式的实现没有考虑线程安全问题，它的线程是不安全的，并发环境下很可能出现多个Singleton实例 在getInstance方法上加同步 123456789public static synchronized Demo getInstance() { // 4. 如果这个对象引用为null，我们就创建并返回出去 if (demo == null) { demo = new Demo(); } return demo; } 双重检查锁定 123456789101112131415161718192021222324252627282930313233public class Demo { // 1.将构造函数私有化，不可以通过new的方式来创建对象 private Demo(){} // 2.先不创建对象，等用到的时候再创建 private volatile static Demo demo; public static Demo getInstance() { // 3. 如果这个对象引用为null，我们就创建并返回出去 if (demo == null) { synchronized(Demo.class){ if(demo == null){ demo = new Demo(); } } } return demo; }}并发编程的三个概念：1. 原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。2. 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。3. 有序性：即程序执行的顺序按照代码的先后顺序执行。当变量改变时，会立即存入高速缓存中注意：volatile的两个作用：1. 保证变量在多线程下的可见性2.限制编译器指令重排（禁止指令重排序）但volitile不保证原子性 静态内部类 123456789public class Demo { private static class LazyHolder { private static final Demo DEMO = new Demo(); } private Demo (){} public static final Demo getInstance() { return LazyHolder.DEMO; } } 饿汉式例子（不管有没有这个实例都创建一个对象） 123456789101112public class Demo{ // 1.将构造函数私有化，不可以通过new的方式来创建对象 private Demo(){} // 2.在类的内部创建自行实例 private static Demo demo = new Demo(); // 3.提供获取唯一实例的方法(静态工厂方法) public static Demo getInstance() { return demo; }} 工厂模式工厂模式分为三种：简单工厂模式/静态工厂模式、工厂方法模式、抽象工厂模式 需要有工厂类以及对象类 1. 简单工厂模式/静态工厂模式将对象实例化代码抽取到工厂中 1234567891011121314151617181920212223242526272829303132333435363738abstract class Animal{ public abstract String getName();}class Cat extends Animal{ public String getName(){ return &quot;I'm cat&quot;; }}class Dog extends Animal{ public String getName(){ return &quot;I'm dog&quot;; }}... pigclass SimpleFactory { public static Animal createInstance(String type) { if (&quot;cat&quot;.equals(type)) { return new Cat(); } else if (&quot;dog&quot;.equals(type)) { return new Dog(); } else if (&quot;pig&quot;.equals(type)) { return new Pig(); } else { throw new RuntimeException(&quot;type[&quot; + type + &quot;]类型不可识别，没有匹配到可实例化的对象！&quot;); } }}public class Demo { public static void main(String[] args) { Cat cat = SimpleFactory.createInstance(&quot;cat&quot;); System.out.println(&quot;创建的动物实例为:&quot; + cat.getName()); Dog dog = SimpleFactory.createInstance(&quot;dog&quot;); System.out.println(&quot;创建的动物实例为:&quot; + dog.getName()); }} 缺点：如果要生产其他动物，需要添加具体类以及修改工厂类 2. 工厂方法模式定义了一个创建对象的接口，由子类决定要实例化的类是哪一个，工厂方法让类吧实例化推迟到子类 1234567891011121314151617181920212223242526272829303132333435abstract class AnimalFactory { public abstract Animal[] createAnimal();}//猫工厂class CatFactory extends AnimalFactory { @Override public Animal[] createAnimal() { return new Animal[]{new WhiteCat(), new BlackCat()}; }}// 狗工厂class DogFactory extends AnimalFactory { @Override public Animal[] createAnimal() { return new Animal[]{new WhiteDog(), new BlackDog()}; }}public class Demo { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory; Animal[] cats = catFactory.createAnimal(); System.out.println(&quot;生产的猫的有：&quot;); print(cats); } static void print(Animal[] a) { for (Animal al : a) { System.out.println(al.getName()); } }} 3. 抽象工厂模式提供一个接口，英语创建相关或者依赖对象的家族，而不需要明确制定具体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354abstract class Animal { public abstract String getName();}abstract class Cat extends Animal {}abstract class Dog extends Animal {}class WhiteCat extends Cat { @Override public String getName() { return &quot;白猫&quot;; }}class BlackDog extends Dog { @Override public String getName() { return &quot;黑狗&quot;; }}interface AbstractAnimalFactory { Cat createCat(); Dog createDog();}class AnimalFactory implements AbstractAnimalFactory { @Override public Cat createCat(){ return new WhiteCat(); } @Override public Dog createDog(){ return new BlackDog(); }}public class Demo { public static void main(String[] args) { AbstractAnimalFactory animalFactory = new AnimalFactory(); Cat cat = animalFactory.createCat(); Dog dog = animalFactory.createDog(); System.out.println(cat.getName()); System.out.println(dog.getName()); }} …未完待续","link":"/2019/07/09/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"获取天气信息","text":"​ 其实获取天气报告之前做android的时候就有做过（之前好像使用JSONObject来解析的），我这边再记录一下使用ajax的方式来获取天气信息，天气预报功能来源于高德地图API和和风天气API组合而成，能够查看当前IP地址所在地的近三日天气，看效果图 来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;获取天气情况&lt;/title&gt; &lt;!--引入JQuery--&gt; &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!--获取天气预报--&gt; &lt;script&gt; $(function(){ /*先获取位置（也就是要获取那个地方的天气：比如广州）、再获取天气预报的信息*/ //使用ajax的方式获取 $.ajax({ /*参数解析： url: 表示访问的地址 type: 请求的方式：get方式 success: 访问成功后执行的方法，里面的参数表示请求返回的对象 */ url: &quot;http://restapi.amap.com/v3/ip?key=11ddf2f282ee4c39d35a46c3a4dae845&quot;, type: &quot;get&quot;, success: function(responseText1){//responseText1为一个json对象 /* 照样使用ajax请求，注意url后面添加了一个参数（根据responseText1获取城市并传递过去） */ $.ajax({ url: &quot;https://free-api.heweather.com/s6/weather/forecast?key=d66df9e9bec5484da78f88a5bb58d092&amp;location=&quot;+responseText1.city, type: &quot;get&quot;, success: function(responseText2){//responseText2照样也是一个json对象 $(&quot;#showForecast h1&quot;).html(responseText1.city+&quot;近三天天气&quot;); //获取responseText2对象里面的HeWeather6（数组），获取第一个对象里面的daily_forecast（数组） var jsonObj = responseText2.HeWeather6[0].daily_forecast; //做遍历 for(var i = 0; i &lt; jsonObj.length; i++){ var date = jsonObj[i].date; var weather = jsonObj[i].cond_txt_d; var low = jsonObj[i].tmp_min; var hight = jsonObj[i].tmp_max; //展示到页面 $(&quot;#showForecast&quot;).append(&quot;&lt;p&gt;&quot;+ date + &quot;:&quot; + weather + &quot;，温度: &quot; + low+ &quot; ~ &quot; + hight + &quot;℃&lt;/p&gt;&quot;); } }, error: function(){ alert(&quot;获取天气失败&quot;); } }); }, error: function(){ alert(&quot;获取定位失败&quot;); } }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--显示天气预报--&gt; &lt;div id=&quot;showForecast&quot; align=&quot;center&quot;&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上的代码已经将功能实现，下面进行解析： 第一个ajax的时候responseText1为一个json对象，内容如下： （可以把地址复制粘贴到浏览器的地址栏就可以看到） 123456789{status: &quot;1&quot;,info: &quot;OK&quot;,infocode: &quot;10000&quot;,province: &quot;广东省&quot;,city: &quot;广州市&quot;,adcode: &quot;440100&quot;,rectangle: &quot;113.1017375,22.93212254;113.6770499,23.3809537&quot;} 这个city是广州，如果想更换成其他的城市，需要更换（http://restapi.amap.com/v3/ip?key=11ddf2f282ee4c39d35a46c3a4dae845）key的值 第二个ajax你可以看到url这个位置传入一个city参数，就是第一个ajax获取的responseText1的city responseText2的内容如下：（主要获取daily_forecast数组的值，然后遍历显示在页面） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889{ HeWeather6: [{ basic: { cid: &quot;CN101280101&quot;, location: &quot;广州&quot;, parent_city: &quot;广州&quot;, admin_area: &quot;广东&quot;, cnty: &quot;中国&quot;, lat: &quot;23.12517738&quot;, lon: &quot;113.28063965&quot;, tz: &quot;+8.00&quot; }, update: { loc: &quot;2019-07-10 10:57&quot;, utc: &quot;2019-07-10 02:57&quot; }, status: &quot;ok&quot;, daily_forecast: [{ cond_code_d: &quot;306&quot;, cond_code_n: &quot;302&quot;, cond_txt_d: &quot;中雨&quot;, cond_txt_n: &quot;雷阵雨&quot;, date: &quot;2019-07-10&quot;, hum: &quot;76&quot;, mr: &quot;13:16&quot;, ms: &quot;00:34&quot;, pcpn: &quot;2.1&quot;, pop: &quot;55&quot;, pres: &quot;1003&quot;, sr: &quot;05:48&quot;, ss: &quot;19:16&quot;, tmp_max: &quot;30&quot;, tmp_min: &quot;25&quot;, uv_index: &quot;1&quot;, vis: &quot;13&quot;, wind_deg: &quot;-1&quot;, wind_dir: &quot;无持续风向&quot;, wind_sc: &quot;1-2&quot;, wind_spd: &quot;10&quot; }, { cond_code_d: &quot;306&quot;, cond_code_n: &quot;104&quot;, cond_txt_d: &quot;中雨&quot;, cond_txt_n: &quot;阴&quot;, date: &quot;2019-07-11&quot;, hum: &quot;70&quot;, mr: &quot;14:13&quot;, ms: &quot;01:14&quot;, pcpn: &quot;5.3&quot;, pop: &quot;65&quot;, pres: &quot;1004&quot;, sr: &quot;05:48&quot;, ss: &quot;19:16&quot;, tmp_max: &quot;31&quot;, tmp_min: &quot;26&quot;, uv_index: &quot;1&quot;, vis: &quot;20&quot;, wind_deg: &quot;-1&quot;, wind_dir: &quot;无持续风向&quot;, wind_sc: &quot;1-2&quot;, wind_spd: &quot;6&quot; }, { cond_code_d: &quot;302&quot;, cond_code_n: &quot;101&quot;, cond_txt_d: &quot;雷阵雨&quot;, cond_txt_n: &quot;多云&quot;, date: &quot;2019-07-12&quot;, hum: &quot;72&quot;, mr: &quot;15:11&quot;, ms: &quot;01:55&quot;, pcpn: &quot;0.0&quot;, pop: &quot;25&quot;, pres: &quot;1003&quot;, sr: &quot;05:49&quot;, ss: &quot;19:15&quot;, tmp_max: &quot;34&quot;, tmp_min: &quot;27&quot;, uv_index: &quot;2&quot;, vis: &quot;24&quot;, wind_deg: &quot;-1&quot;, wind_dir: &quot;无持续风向&quot;, wind_sc: &quot;1-2&quot;, wind_spd: &quot;9&quot; } ] }]} 第二个ajax的用法在代码中已有注释 背景： 嗯，下面来介绍一下上面的背景吧，这个也是偶尔看到的，也非常的简单实用，让背景不再单调 项目github地址为：https://github.com/VincentGarreau/particles.js 关于使用看这边文章：https://blog.csdn.net/csdn_yudong/article/details/53128570","link":"/2019/07/10/%E8%8E%B7%E5%8F%96%E5%A4%A9%E6%B0%94%E4%BF%A1%E6%81%AF/"},{"title":"游戏装服流程","text":"一、中央服装服流程需要将基础环境搭建好才能进行以下操作 123456mysql 5.6.13mongodb 3.6.12nginx (稳定版本)php 7.3.10(启动php-fpm)redis 7.0.11erlnag25(otp_src_25.2.1) 1、搭建redis依赖(需要支持持久化)1234567891011121314151617181920212223242526272829303132# 创建目录mkdir /data/redis/33379/{conf,data,logs} -p# 配置cp -a /usr/local/redis-7.0.11/redis.conf /data/redis/33379/conf/# 修改/data/redis/33379/conf/redis.conf配置---- 33379 ----bind 127.0.0.1protected-mode yes #开启保护模式port 33379 #端口pidfile /var/run/redis_33379.pid #进程idlogfile /data/redis/33379/logs/redis-server.log #日志dir /data/redis/33379/data/ #数据目录repl-diskless-sync noappendonly yes #开启持久化requirepass zusI9fuCMI5eHP2X #设置密码 rename-command FLUSHALL &quot;&quot;rename-command CONFIG &quot;&quot;rename-command EVAL &quot;&quot;# 测试（在/root/目录下创建脚本start-redis.sh)#!/bin/bash/usr/local/redis-7.0.11/bin/redis-server /data/redis/33379/conf/redis.conf &amp;#启动redissh /root/start-redis.sh#连接（因为上面设置了密码、所以也需要密码连接）/usr/local/redis-7.0.11/bin/redis-cli -h 127.0.0.1 -p 33379 -a zusI9fuCMI5eHP2X ping# 返回pong则为成功 2、创建日志目录(存放log目录 server Nginx)1mkdir -p /data/logs 3、中央服3.1、创建目录1mkdir /data/wxh5_center_f001a/{mysql,mongodb,html/hhsy,sh,server,DBCombine} -p 3.2、mysql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 2.1、切换到mysql目录cd /data/wxh5_center_f001a/mysql# 2.2、拉取mysql文件(从外网服获取相应的脚本)close-mysql.shfswr_mdata.tgzmysqldump.shmysql_install_fswr.shportstart-mysql.shmy.cnf# sql文件# 2.3、编写mysql的端口echo 33001 &gt; port# 2.4、安装(mysql实例)bash mysql_install_fswr.sh master# 2.5、检查端口是否正常启动netstat -ntlup | grep `cat port`# 2.6、修改mysql密码# 需要将数据库密码写入 /usr/local/mysql/docs/help 中（第一行为内网的密码，第二行为正式服用的密码)/usr/local/mysql/bin/mysql -h127.0.0.1 -P`cat port` -uroot -p`sed -n 1p /usr/local/mysql/docs/help`# 这个密码在安装mysql的时候就已是设置到mysq.user表中# 装服内网的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'abc123456' WITH GRANT OPTION;flush privileges;# 装服正式服的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;UPDATE user SET Password = password('test123456') WHERE User='root';flush privileges;# 2.7、导表# 创建muti_lang_center数据库create database muti_lang_center default character set utf8;# 导入表数据# 内网用# /usr/local/mysql56/bin/mysql -uroot -p`sed -n 1p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port)/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; muti_lang_center.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_current.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_lang.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_menu.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_permit.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_user_group.sql &amp;&amp;\\/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P$(cat port) muti_lang_center &lt; xxwd_user.sql 3.3、mongodb123456789101112131415161718# 3.1、切换目录cd /data/wxh5_center_f001a/mongodb# 3.2、所需的文件(从外网服获取相应的脚本)close_mongodb_master_by_pidfile.shmongodump.shportstart_mongodb_master.shmongodb.conf# 3.3、编写mongodb端口 echo 23001 &gt; port# 3.4、启动mongodbbash start_mongodb_master.sh# 3.5、检查端口是否正常启动netstat -ntlup | grep `cat port` 3.4、html (从gitlab中的phpServer中拉取）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 4.1、需要php代码文件 /data/wxh5_center_f001a/html/hhsy/ -center/ -cluster/ -server/ -single/ -sy_extends/ (这个不用，目前用不上)# 4.2、切换目录/data/wxh5_center_f001a/html# 4.3、修改所属用户和组chown -R www.www hhsy/# 4.4、修改配置文件hhsy/center/application/database.phphhsy/cluster/application/database.php----------start----------------return [ // 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '127.0.0.1', //线上 10.20.1.1 // 数据库名 ‘database’ =&gt; 'muti_lang_center', // 用户名 'username' =&gt; 'root', // 密码 'password' =&gt; 'abc123456', // 正式服用 test123456 // 端口 'hostport' =&gt; '33001']--------------end------------hhsy/center/application/config.phphhsy/cluster/application/config.php----------start----------------# 以新配置为准'mongo_config_login' =&gt; [ // 主库 ‘master’ =&gt; [ // mongo主机内网ip 'inside_host' =&gt; '127.0.0.1', // mongo主机 'host' =&gt; '23002' ], // 从库 'slave' =&gt; [ // mongo主机 'host' =&gt; '127.0.0.1', // mongo端口 'port' =&gt; '23001' ]]----------end------------------# 4.5、修改标题hhsy/center/application/admin/view/common/header.html# 4.6、赋予目录权限chmod -R 777 hhsy/center/runtimechmod -R 777 hhsy/cluster/runtime 3.5、fastcgi修改配置文件 /usr/local/php7.3.10/etc/php-fpm.d/www.conf 12345pm = dynamicpm.max_children = 600pm.start_servers = 30pm.min_spare_servers = 30pm.max_spare_servers = 400 重启fastcgi 12bash /root/fastcgi_kill_all.shbash /root/fastcgi_start.sh 3.6、Nginx配置需要SSL证书 /usr/local/nginx/conf/vhost/wxh5-center.gameone.com.conf （文件名称视具体域名来定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364server{ listen 9480; listen 9443 ssl; server_name wxh5-data.gameone.com; # 这个视具体的域名来定 root /data/wxh5_center_f001a/html/hhsy/center/public/; index index.html index.htm index.php; charset utf-8; proxy_ignore_client_abort on; expires 2h; ssl_certificate ssl/gameone.com.pem; ssl_certificate_key ssl/gameone.com.key; ssl_protocols SSLv2 SSLv3 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; client_max_body_size 100m; location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ~ .*\\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; expires off; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.swf$ { expires 72h; } location ~ .*\\.css$ { expires 96h; } location ~ .*\\.xml$ { expires 12h; } location ~ .*\\.js$ { expires 96h; } location ~ .*\\.jpg$ { expires 96h; } location ~ .*\\.gif$ { expires 96h; } location ~ .*\\.png$ { expires 96h; } location ~ .*\\.mp3$ { expires 400h; } location ~ /\\.svn/ { return 403; } location ~* \\.(sh|log|sh|sql|svn|tar|gz|svn-base) { root ~; deny all; } access_log /data/logs/wxh5-center.log;} /usr/local/nginx/conf/vhost/wxh5-data.gameone.com.conf （文件名称视具体域名来定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364server{ listen 8480; listen 8443 ssl; server_name wxh5-data.gameone.com; # 这个视具体的域名来定 root /data/wxh5_center_f001a/html/hhsy/cluster/public/; index index.html index.htm index.php; charset utf-8; proxy_ignore_client_abort on; expires 2h; ssl_certificate ssl/gameone.com.pem; ssl_certificate_key ssl/gameone.com.key; ssl_protocols SSLv2 SSLv3 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; client_max_body_size 100m; location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ~ .*\\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; expires off; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.swf$ { expires 72h; } location ~ .*\\.css$ { expires 96h; } location ~ .*\\.xml$ { expires 12h; } location ~ .*\\.js$ { expires 96h; } location ~ .*\\.jpg$ { expires 96h; } location ~ .*\\.gif$ { expires 96h; } location ~ .*\\.png$ { expires 96h; } location ~ .*\\.mp3$ { expires 400h; } location ~ /\\.svn/ { return 403; } location ~* \\.(sh|log|sh|sql|svn|tar|gz|svn-base) { root ~; deny all; } access_log /data/logs/wxh5-data.log;} 配置完成后重新启动Nginx 1bash /root/nginx_reload.sh 3.7、定时任务1230 */1 * * * sh /data/wxh5_center_f001a/html/hhsy/center/application/crontab/crontab_1_minutes.sh 1&gt;&amp;2 2&gt;/dev/null0 5 * * * sh /data/wxh5_center_f001a/html/hhsy/center/application/crontab/crontab_5.00_am.sh 1&gt;&amp;2 2&gt;/dev/null*/1 * * * * sh /data/wxh5_center_f001a/html/hhsy/center/application/crontab/crontab_5_minutes.sh 1&gt;&amp;2 2&gt;/dev/null 3.8、测试1https://wxh5-data.gameone.com:9443/admin/index/index //后台 4、IdServer服idServer 此服务需要Redis支持,所有游戏服要内网能访问到此服务。 拷贝目录下面的confg.cnf配置端口和redis连接地址。此redis需要持久化 要redislog持久化操作，保证数据可还原. 12345678910111213141516171819202122232425262728# 1、拉取资源 (从外网服拉）mkdir -p /data/idServer/ rsync -e &quot;ssh -p22-azvP ip:/data/idServer/* /data/idServer/# 2、配置(config.cnf)---------start-----------db=127.0.0.1:33379pass=zusI9fuCMI5eHP2X # 启动redis配置的密码port=:52888-----------end---------# 3、启动# 如果没有安装screen 则先安装 yum -y install screen# 执行这个命令先将redis启动起来# sh startRedis.shscreen -S idServer # 创建 screen./idserver &amp; # 启动后关闭终端（使用快捷键Ctrl+A+D, 关闭窗口即可实现程序的后台运行）# 设置玩家初始id# 连接上redis/usr/local/redis-7.0.11/bin/redis-cli -h 127.0.0.1 -p 33379 -a zusI9fuCMI5eHP2Xselect 1 #选择数据库1keys * # 查看所有的key 会出现 “/1&quot; 这个就是key值get /1 // 可以查看当前的&quot;/1&quot; 对应的值为多少set /1 10000000 // 设置 key“/1” 的值#与redis断开连接quit // 输入指令 二、游戏服装服流程（在游戏服中的操作）1、创建目录1mkdir -p /data/mcwx_mixed_s001a/{html/hhsy/,mysql,server,sh} 2、mysql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 2.1（从中央服获取脚本）cd /data/mcwx_mixed_s001a/mysql/rsync -azvP 172.20.30.6{中央服ip}:/data/wxh5_center_f002a/mysql/{*.sh,port,fswr_mdata.tgz,my.cnf} ./rsync -azvP 43.154.100.178{中央服ip}:/data/ghzslg_release/20230518/{all_null_*,entry_all.sql} ./# 2.2、修改端口echo 32001 &gt; port# 2.3、安装mysql实例bash mysql_install_fswr.sh master# 2.3、检查端口是否正常启动netstat -tunpl | grep `cat port`# 2.4、创建数据库# 需要将数据库密码写入 /usr/local/mysql/docs/help 中（第一行为内网的密码，第二行为正式服用的密码)/usr/local/mysql/bin/mysql -h127.0.0.1 -P`cat port` -uroot -p`sed -n 1p /usr/local/mysql/docs/help`# 装服内网的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'abc123456' WITH GRANT OPTION;flush privileges;# 装服正式服的操作（更改密码并授权）use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;UPDATE user SET Password = password('test123456') WHERE User='root';flush privileges;# 这个密码在安装mysql的时候就已是设置到mysq.user表中# 内网用/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 1p /usr/local/mysql/docs/help` -P$(cat port)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_admin&quot;/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_game&quot;# 2.5、导表 (mxqy_game)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_game &lt; ./all_null_table.sql # 2.6、插入sql语句（注意里面的ip为中央服的ip地址）/usr/local/mysql56/bin/mysql -uroot -p`sed -n 2p /usr/local/mysql/docs/help` -h127.0.0.1 -P`cat port` mxqy_gameINSERT INTO `serverUrl` VALUES ('1', 'http://172.20.30.12(中央服ip):52888/1', '1');INSERT INTO `serverUrl` VALUES ('13', 'http://172.20.30.12(中央服ip):52888/test', '1');# 2.7、导表（mxqy_admin)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_admin &lt; ./all_null_admin.sql# 2.8、授权/usr/local/mysql56/bin/mysql -uroot -p$(sed -n 2p /usr/local/mysql/docs/help) -h127.0.0.1 -P$(cat port) -e &quot;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;&quot;/usr/local/mysql56/bin/mysql -uroot -p$(sed -n 2p /usr/local/mysql/docs/help) -h127.0.0.1 -P$(cat port) -e &quot;flush privileges;&quot;# 2.9、插入开服日期/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) insert into mxqy_game.serverConfig values (202,1,'2024-05-20'); 格式：202，server_id,开服日期 3、html1234567# 3.1、从中央服拉rsync -azvP 172.20.30.6{中央服ip}:/data/wxh5_center_f001a/html/hhsy/{single,server} /data/mcwx_mixed_s001a/html/hhsy/# 3.2、配置（修改端口和密码）chown www.www -R html/# 后台设置同步过来vim /data/mcwx_mixed_s001a/html/hhsy/single/config/database.php #mysql 4、server1234567891011121314151617# 从外网服拉取# 4.1 修改配置 （连接数据配置的修改）/data/mcwx_mixed_s001a/server/config/server.app# 4.2 修改启动脚本/data/mcwx_mixed_s001a/server/sh/main.shNUM=100 # 1服 (服id*100)# 4.3 需要获得最新的ebin文件# 4.4 启动cd /data/mcwx_mixed_s001a/server/sh/bash main.sh start# 4.5 检查netstat -tunpl | grep 10501 # 这个端口为上面配置端口+1 5、添加nginx配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server{ listen 4001; # 服id + 4000 server_name 43.154.183; # 对应的ip地址 root /data/mcwx_mixed_s001a/html/hhsy/single/public; index index.html index.htm index.php; add_header Access-Control-Allow-Origin *; charset utf-8; expires -1; client_max_body_size 100m; location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ~ .*\\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; expires off; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } location ~ .*\\.swf$ { expires 72h; } location ~ .*\\.css$ { expires 96h; } location ~ .*\\.xml$ { expires 12h; } location ~ .*\\.js$ { expires 96h; } location ~ .*\\.jpg$ { expires 96h; } location ~ .*\\.gif$ { expires 96h; } location ~ .*\\.png$ { expires 96h; } location ~ .*\\.mp3$ { expires 400h; } location ~ /\\.svn/ { return 403; } location ~* \\.(txt|sh|xls|doc|log|sh|sql|svn|tar|gz|svn-base) { root ~; deny all; } access_log /data/logs/mcwx_mixed_s001a.log;} 重启nginx 1bash /root/nginx-reload.sh 这个nginx端口需要开放出来 6、去数据后台添加新增的服信息三、跨服路由机1 、创建目录1mkdir /data/mcwx_travel_s99001a/{html,mysql,server,sh} 2 、mysql1234567891011121314151617181920212223242526272829303132#2.1 、拉取文件(**从中央服获取脚本 或者直接从**https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/mysql_sh**获取**)cd /data/mcwx_travel_s99001a/mysql#2.2、修改端口echo 31001 &gt; port# 2.3、安装bash mysql_install_fswr.sh master# 2.4、检查端口是否正常启动netstat -tunpl | grep `cat port`# 2.5、创建数据库#(修改mysql密码 )/usr/local/mysql/bin/mysql -h127.0.0.1 -P`cat port` -uroot -p`sed -n 1p /usr/local/mysql/docs/help`use mysql;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'test123456' WITH GRANT OPTION;UPDATE user SET Password = password('test123456') WHERE User='root';flush privileges;# 这个密码在安装mysql的时候就已是设置到mysq.user表中/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_admin&quot;/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) -e &quot;create database mxqy_game&quot;# 2.6、导表 (mxqy_game)# 获取sql文件（https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/server/sql）/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_game &lt; ./mxqy_game.sql# 2.7、导表（mxqy_admin)/usr/local/mysql56/bin/mysql -h127.0.0.1 -u root -p`sed -n 2p /usr/local/mysql/docs/help` -P$(cat port) mxqy_admin &lt; ./mxqy_admin.sql 3、server1234567891011121314151617181920# 获取（https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/server)# 3.1 修改配置 （连接数据配置的修改）/data/mcwx_mixed_s001a/server/config/server.appserverId = 99001 # 99000+1port = 35001server.app多了一个 serverType配置，路由机的类型是3 ，工作机的类型是4其他跟之前一样# 3.2 修改启动脚本/data/mcwx_travel_s99001a/server/sh/main.shnum=9900100 # 服id*100# 3.2 获取最新的ebin文件从（https://gitlab.dele.com/wulinmengxia/serverscript/-/tree/master/server/ebin 获取）# 3.3 启动cd /data/mcwx_mixed_s001a/server/sh/bash main.sh start 工作机1、创建目录1mkdir /data/ghzslg_travel_s99002a/ 2、mysql2.1 拉取文件1rsync -azvP 172.20.30.6:/data/ghzslg_center_f001a/mysql/{*.sh,port,fswr_mdata.tgz,*.sql,my.cnf} /data/ghzslg_travel_s99002a/mysql/ 2.2 切换目录1echo 31001 &gt; port 2.4 安装12bash mysql_install_fswr.sh masternetstat -tunpl | grep `cat port` 2.5 检查1netstat -tunpl | grep `cat port` 2.6 配置123跨服server.app多了一个 serverType配置，路由机的类型是3 ，工作机的类型是4其他跟之前一样 需要开发的端口1234567891011121380433# http://192.168.56.101:52888/test# 获得玩家id52888# firewall-cmd --permanent --add-port=80/tcp# firewall-cmd --reload94804008 // 游戏服single 杂项1234# 打包排除 (排除log下的所有文件)tar -zcvf hhsy.tar.gz --exclude=./hhsy/center/runtime/log/* --exclude=hhsy/cluster/runtime/log/* ./hhsy# 打包排除（排除log文件夹）tar -zcvf hhsy.tar.gz --exclude=./hhsy/center/runtime/log --exclude=hhsy/cluster/runtime/log ./hhsy","link":"/2024/05/11/%E6%B8%B8%E6%88%8F%E8%A3%85%E6%9C%8D%E6%B5%81%E7%A8%8B/"},{"title":"过滤器与监听器","text":"实现一个简单的过滤器我们可以在执行doFilter()方法前做一些预处理 通过xml配置 第一步编写一个类实现 Filter接口 12345678public class FilterDemo implements Filter{ //其中init()和destory()方法跟Servlet一样，只有在Web服务器加载和销毁的时候才被执行，只会执行一次 public void destory(){} public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws ServletException, IOException { chain.doFilter(req,resp)；//执行这个表示为放行 }} 第二步 filter的部署(在web.xml文件中配置) 123456789101112&lt;filter&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;&lt;!--过滤器名称--&gt; &lt;filter-class&gt;com.heclam.FilterDemo&lt;/filter-class&gt;&lt;!--限定类名--&gt; &lt;init-param&gt;&lt;!--过滤器初始化参数--&gt; &lt;param-name&gt;testFile&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/abc.txt&lt;/param-value&gt; &lt;/init-param&gt; &lt;filter-mapping&gt;&lt;!--用于拦截资源--&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;&lt;!--与上面的名称一致--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--拦截请求路径--&gt; &lt;/filter-mapping&gt;&lt;/filter&gt; 通过注解配置12@WebFilter(filterName=&quot;FilterDemo2&quot;,urlPatterns=&quot;/*&quot;)public filterDemo2 implements Filter{} 监听器Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁、或者往其中添加修改删除属性时自动执行代码的功能组件。 ServletContextListener : 对Servlet上下文的创建和销毁进行监听 ServletContextAttributeListener ：监听Servlet上下文属性的添加、删除和替换 HttpSessionListener HttpSessionAttributeListener ServletRequestListener ServletRequestAttributeListener Servlet3从Servlet3开始，Servlet3提供了基于注解的部署方式，可以分别使用WebServlet、WebFilter、WebListener进行部署servlet、过滤器、监听器","link":"/2019/07/09/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"}],"tags":[{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"JDk","slug":"JDk","link":"/tags/JDk/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Spring事务","slug":"Spring事务","link":"/tags/Spring%E4%BA%8B%E5%8A%A1/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"java线程","slug":"java线程","link":"/tags/java%E7%BA%BF%E7%A8%8B/"},{"name":"markdown语法","slug":"markdown语法","link":"/tags/markdown%E8%AF%AD%E6%B3%95/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"新技能","slug":"新技能","link":"/tags/%E6%96%B0%E6%8A%80%E8%83%BD/"},{"name":"gameServer","slug":"gameServer","link":"/tags/gameServer/"},{"name":"过滤器","slug":"过滤器","link":"/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"监听器","slug":"监听器","link":"/tags/%E7%9B%91%E5%90%AC%E5%99%A8/"}],"categories":[{"name":"javaWeb","slug":"javaWeb","link":"/categories/javaWeb/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"教程","slug":"笔记/教程","link":"/categories/%E7%AC%94%E8%AE%B0/%E6%95%99%E7%A8%8B/"},{"name":"gameServer","slug":"gameServer","link":"/categories/gameServer/"}],"pages":[{"title":"about","text":"keep move!","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}