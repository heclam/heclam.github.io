```
title: 了解一下Redis
date: 2019-8-25 14:40:19
toc: true
categories:
	- Redis
tags:
	- Redis
```



##### Redis支持以下五种类型

* String
* list
* set
* SortedSet
* Hash<!--more-->

#### 键的过期时间

 * 设置键的<font color=red>生存</font>时间可以通过**EXPIRE**或者**PEXPIRE**
 * 设置键的<font color=red>过期</font>时间可以通过**EXPIREAT**或者**PEXPIREAT**

其实`EXPIRE`、`PEXPIRE`、`EXPIREAT`这三个命令都是通过`PEXPIREAT`命令来实现的

#### 过期策略

 * 过期键是保存在哈希表中了。那这些过期键到了过期的时间，就会立马被删除掉吗？？

 * 删除策略可以分为三种：

    * 定时删除(对内存友好，对CPU不友好)
       * 到时间点上就把所有过期的键删除了
   * 惰性删除(对CPU极度友好，对内存极度不友好)
     * 每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除
   * 定期删除(折中)
     * **每隔**一段时间去删除过期键，**限制**删除的执行时长和频率。

   Redis采用的是**惰性删除+定期删除**两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！

####　Redis持久化

 * Redis提供两种不同的持久化方法来将数据存储到硬盘里面：

    * RDB(基于快照)，将某一时刻的所有数据保存到一个RDB文件中。
    * AOF(append-only-file)，当Redis服务器执行**写命令**的时候，将执行的**写命令**保存到AOF文件中。

* RDB(快照持久化)

  * **流程：** <font color=red>数据库状态</font> --保存-----》 <font color=red>RDB文件</font>		<font color=red>数据库状态</font> 《----还原--- <font color=red>RDB文件</font>	

  * 有两个命令可以生成RDB文件：

    * `SAVE`会**阻塞**Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止
    * `BGSAVE`创建出一个**子进程**，由子进程来负责创建RDB文件，服务器进程可以继续接收请求。

  * Redis服务器在启动的时候，如果发现有RDB文件，就会**自动**载入RDB文件(不需要人工干预)

    * 服务器在载入RDB文件期间，会处于阻塞状态，直到载入工作完成。

  * 除了手动调用`SAVE`或者`BGSAVE`命令生成RDB文件之外，我们可以使用配置的方式来**定期**执行

    ```
     save 900 1              #在900秒(15分钟)之后，至少有1个key发生变化，
     save 300 10            #在300秒(5分钟)之后，至少有10个key发生变化
     save 60 10000        #在60秒(1分钟)之后，至少有10000个key发生变化
    ```

* AOF(文件追加)

  * **流程：** <font color=red>客户端</font> ---发送写的命令----》<font color=red>服务器</font> ----保存被执行的写命令-----》<font color=red>AOF文件</font> 
  * AOF持久化功能的实现可以分为3个步骤：
    * 命令追加：命令写入aof_buf缓冲区
    * 文件写入：调用flushAppendOnlyFile函数，考虑是否要将aof_buf缓冲区写入AOF文件中
    * 文件同步：考虑是否将内存缓冲区的数据真正写入到硬盘



#### 主从框架

![](https://i.loli.net/2019/08/31/EmJOWLKnpDaFgrB.png)

##### 主从框架的特点

 * 主服务器负责接受写请求
 * **从**服务器负责接收**读**请求
 * 从服务器的数据由主服务器**复制**过去。主从服务器的数据是**一致**的

主从框架的好处：

 * 读写分离(主服务器负责写，从服务器负责读)
 * 高可用(某一台从服务器挂了，其他从服务器还能继续接收请求，不影响服务)
 * 处理更多的并发量(每台从服务器**都可以接收读请求**，读QPS就上去了)

#### 复制功能

主从架构的特点之一：主服务器和从服务器的数据是**一致**的。

<font color=red>**Redis服务器（主）**</font> 《-----------复制-------------------   <font color=red>**Redis服务器（主）**</font> 

 * 复制功能分为两个步骤
    * 同步（sync）
       * 将从服务器的数据库状态**更新至**主服务器的数据库状态
   * 命令传播(command propagate)
     * 主服务器的数据库状态**被修改**，导致主从服务器的数据库状态**不一致**，让主从服务器的数据库状态**重新回到一致状态**。

* 从服务器对主服务器的**同步又可以分为两种情况**：
  * 初次同步：从服务器**没有复制过任何**的主服务器，或者从服务器要复制的主服务器跟上次复制的主服务器**不一样**。
  * 断线后同步：处于**命令传播阶段**的主从服务器因为**网络原因**中断了复制，从服务器通过**自动重连**重新连接主服务器，并继续复制主服务器



#### 哨兵(Sentinal)机制

​	哨兵机制可以监控，但主服务器瘫痪了之后，可以指定一台从服务器为新的主服务器,如果旧的主服务器接上来，那么旧的主服务器成为了从服务器

#### 缓存雪崩

#####  	什么是缓存雪崩？

* 如果缓存数据**设置的过期时间是相同**的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存**同时失效**，全部请求到数据库中。

* 这就是缓存雪崩：

  * Redis挂掉了，请求全部走数据库。

  * 对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。

     缓存雪崩如果发生了，很可能就把我们的数据库**搞垮**，导致整个服务瘫痪！

##### 解决方法

 	在缓存的时候给过期时间加上一个**随机值**，这样就会大幅度的**减少缓存在同一时间过期**。

 	**对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路**

* 事发前：实现Redis的高可用（主从框架+Sentinel(哨兵)或者Redis Cluster）,尽量避免Redis挂掉这种情况发生。

* 事发中：万一Redis真的垮了，我们可以设置本地缓存（ehcache）+限流（hystrix）,尽量避免我们的数据库被干掉（起码能保证我们的服务还是能正常工作的）

* 事发后： redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。



#### 缓存穿透

#####  什么是缓存穿透？

* 比如数据库后台表的ID都是大于1的书，每次请求的ID都是负数，这会导致我们的缓存不起作用，请求全部都去找数据库了，但数据库也没有这个值，所以每次返回都是空。

* 缓存穿透是指查询一个一定**不存在的数据**。由于缓存不命中，并且出于容错考虑，如果从**数据库查不到数据则不写入缓存**，这将导致这个不存在的数据**每次请求都要到数据库去查询**，失去了缓存的意义。

#####  这就是缓存穿透：

* 请求的数据在缓存大量不命中，导致请求走数据库。

* 缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！

##### 解决方法

解决缓存穿透的两种方案：

* 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！

* 当我们从数据库找不到的时候，我们也将这个**空对象设置到缓存里边去**。下次再请求的时候，就可以从缓存里边获取了。
  * 这种情况我们一般会将空对象设置一个**较短的过期时间**。

